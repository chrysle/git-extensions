#!/bin/bash

shopt -qs extglob

printUsage()
{
    cat <<HELPTEXT
Check out all / the last committed N local branches (except for the current branch
and master) one by one and execute COMMANDLINE on each branch. If no COMMANDLINE
is given, just performs the checkout and returns to the shell; the next
iteration is then triggered by re-executing with --continue, which can also be
used to continue with COMMANDLINE execution in case an unclean exit or a
left-behind dirty working copy made the command to fall out of the iteration.
HELPTEXT
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-y|--yes] [--continue|--abort] [--branches "<branch1> ..."] [N] COMMANDLINE'
}

isYes=
branchNum=9999
inputBranches=
iterationAction=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)		    shift; printUsage "$0"; exit 0;;
	--yes|-y)		    shift; isYes=t;;
	--branches)		    shift; inputBranches=$1; shift;;	# Internal hook to pass in the branches.
	--continue|--abort)	    iterationAction=${1#--}; shift; break;;
	+([0-9]))		    branchNum=$1; shift;;
	*)			    break;;
    esac
done
[ $# -eq 0 ] && isYes=t	# No need to confirm when no command-line is passed; user can abort via --abort interactively.

gitDir=$(git rev-parse --git-dir 2>/dev/null) || exit $?
origBranchStore="${gitDir}/localbrOrig"
branchStore="${gitDir}/localbr" || exit $?
commandLineStore="${gitDir}/localbrCommandLine"

commandLineEscape()
{
    eval "typeset -a result=(\"\${${1:?}[@]}\")"
    typeset escapeChars="\\${IFS-$' \t\n'}"
    typeset escapeCharIdx
    for ((escapeCharIdx = 0; escapeCharIdx < ${#escapeChars}; escapeCharIdx++))
    do
	result=("${result[@]//"${escapeChars:$escapeCharIdx:1}"/\\"${escapeChars:$escapeCharIdx:1}"}")
    done
    eval "${1}Escaped=(\"\${result[@]}\")"
}
if [ $# -gt 0 ]; then
    typeset -a commandLine=("$@")
    commandLineEscape commandLine
    printf '%s ' "${commandLineEscaped[@]}" > "$commandLineStore" || exit $?
fi

getNextBranch()
{
    [ -f "$branchStore" ] || return
    head -n 1 "$branchStore"
    sed -i '1d' "$branchStore"
    [ -s "$branchStore" ] || rm "$branchStore"
}

dirtyCheck()
{
    if git-dirty; then
	echo >&2 "ERROR: working copy is still dirty; please clean up and then retry with --continue."
	git status
	exit 1
    fi
}

interrupt()
{
    local status=${1:?}
    printf >&2 'Note: Interrupting iteration because the command failed (with exit status %d). Please check and then continue with --continue.\n' "$status"
    echo >&2 'You can suppress checking of exit status by appending "\|\| :" to the COMMANDLINE.'
    exit $status
}

restoreOriginalBranch()
{
    if [ -f "$origBranchStore" ]; then
	git checkout "$(<"$origBranchStore")"
	rm -- "$origBranchStore"
    fi

    [ -e "$commandLineStore" ] && rm -- "$commandLineStore"
    return 0
}

case "$iterationAction" in
    abort)	restoreOriginalBranch; exit 0;;
    continue)
	dirtyCheck

	if [ $# -eq 0 -a -e "$commandLineStore" ]; then
	    # Recall command-line from original / previous call, unless it is
	    # overridden by updated arguments provided to this invocation.
	    commandLineEscaped=$(<"$commandLineStore")
	fi
	;;
    '')
	IFS=$'\n'
	typeset -a localBranches=($(git-localbr $inputBranches | tail -n "$branchNum")) || exit $?
	if [ ${#localBranches[@]} -eq 0 ]; then
	    echo >&2 "No local branches found!"
	    exit 1
	fi

	echo "Iterating over these branch(es):
${localBranches[*]}"
	if [ ! "$isYes" ]; then
	    printf %s "Really iterate over these branches? (y/n) "
	    read answer
	    [ "$answer" = "y" ] || exit 1
	fi

	printf '%s\n' "${localBranches[*]}" > "$branchStore" || exit $?
	git-orig-ref > "$origBranchStore"
	if [ $# -eq 0 -a -e "$commandLineStore" ]; then
	    rm -- "$commandLineStore" || exit $?
	fi
	;;
    *)	printf >&2 'Assert: Unhandled iterationAction %q\n' "$iterationAction"
	exit 3
	;;
esac

while true
do
    branch=$(getNextBranch)
    if [ ! "$branch" ]; then
	echo >&2 "All local branches have been iterated over."

	restoreOriginalBranch
	exit 0
    fi

    git checkout --quiet "${branch}" || exit $?	# Suppress Git's checkout information with --quiet. We're probably not interested in stuff like "Your branch is up-to-date with ...", and we emulate the switch message itself:
    printf "\\nSwitched to branch '%s'\\n" "$branch"
    if [ ${#commandLineEscaped[@]} -eq 0 ]; then
	exit 0
    else
	if (eval "${commandLineEscaped[@]}"); then
	    dirtyCheck
	else
	    interrupt "$?"
	fi
    fi
done
