#!/bin/bash

printUsage()
{
    cat <<HELPTEXT
Execute COMMAND (which probably contains Git command(s)) inside the working copy
that FILE resides in. (Most Git commands only work from within the working
copy.)
--command|-c CMD	The command line to be executed. When this is a simple
			command, it can also be passed as such. Within CMD, you
			can refer to the corresponding FILE via \$FILE, and to
			the root directory of the Git working copy as \$ROOT.
HELPTEXT
    printf 'Usage: %q %s\n' "$(basename "$1")" '-c|--command "COMMANDLINE" [-c ...] | SIMPLECOMMAND [...] [--] FILE [-?|-h|--help]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '-c|--command "COMMANDLINE" [-c ...] | SIMPLECOMMAND [...] -- FILE [...] [-?|-h|--help]'
}

isNeedEval=
typeset -a commands=()
typeset -a files=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--command|-c)	shift; commands+=(${commands:+;} "$1"); isNeedEval=t; shift;;
	--)		shift; files=("$@"); set --; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)  break;;
    esac
done
if [ $# -gt 1 ]; then
    typeset -a simpleCommand=()
    while [ $# -gt 1 ]
    do
	case "$1" in
	    --)	shift; break;;
	    *)  simpleCommand+=("$1"); shift;;
	esac
    done
    if [ "$isNeedEval" ]; then
	# Combine --command and SIMPLECOMMAND; need to quote SIMPLECOMMAND to
	# undo the effects of eval.
	commands+=(${commands:+;} $(printf '%q ' "${simpleCommand[@]}"))
    else
	commands=("${simpleCommand[@]}")
    fi
fi
files+=("$@")

if [ ${#commands[@]} -eq 0 ]; then
    echo >&2 'ERROR: No COMMAND(s) specified; need to pass -c|--command "COMMANDLINE", or SIMPLECOMMAND.'
    exit 2
elif [ ${#files[@]} -eq 0 ] || [ $# -eq 1 -a "$1" = '--' ]; then
    echo >&2 'ERROR: No FILE(s) specified; need a file for the working copy location.'
    exit 2
fi

status=0
for FILE in "${files[@]}"
do
    dirspec=$(dirname -- "$FILE") || { status=$?; continue; }
    if [ ! -d "$dirspec" ]; then
	printf >&2 'ERROR: The directory %s does not exist!\n' "$dirspec"
	status=1; continue
    fi
    if ! cd "$dirspec"; then
	printf >&2 'ERROR: Cannot chdir to %s!\n' "$dirspec"
	status=1; continue
    fi
    if ! ROOT=$(git root 2>/dev/null); then
	printf >&2 'ERROR: %s is not inside a Git working copy!\n' "$dirspec"
	status=1; continue
    fi
    if [ "$isNeedEval" ]; then
	eval "${commands[@]}"
    else
	"${commands[@]}"
    fi || status=$?
done
exit $status
