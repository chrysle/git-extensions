#!/bin/bash
set -o pipefail
shopt -qs extglob

printUsage()
{
    cat <<HELPTEXT
Merge / rebase <branch> to the current branch, then delete it from the local
repository as well as a tracked remote (if it exists there).
HELPTEXT
    printf 'Usage: %q %s\n' "$(basename "$1")" '[--push] [--rebase|--ff|--ff-only|--no-ff|<merge-args> ...] -b|--branch <branch> [...] | [--] <branch> [...]'
    cat <<HELPTEXTCHECK

Merge / rebase <branch> to the current branch, run CHECK-COMMANDS, and if all
succeed (for -c|--commands, for stdin: only with --worst-status, else if the
last succeeds) delete the branch from the local repository as well as a tracked
remote (if it exists there).
HELPTEXTCHECK
    printf 'Usage: %q %s\n' "$(basename "$1")" '[...] -c|--command "CHECK-COMMANDLINE" [-c ...]'
    printf 'Usage: echo CHECK-COMMANDLINES | %q %s\n' "$(basename "$1")" '[...] [--bare|[--trailing-prompt|--no-trailing-prompt] [--emulate-prompt] [--worst-status]] -'
    printf 'Usage: %q %s <<EOF\n  CHECK-COMMANDLINE\n...\nEOF\n' "$(basename "$1")" '[...]'
}

isContinue=
isPush=
hasMergeResolutionArg=
isRebase=
typeset -a branches=()
typeset -a fastForwardArgs=()
typeset -a mergeArgs=()
isBare=
isCheckFromStdin=
typeset -a checkCommandArgs=()
typeset -a checkCommands=()
typeset -a runWithPromptArgs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--continue)	shift; isContinue=t;;
	--push)		shift; isPush=t;;
	--branch|-b)	shift; branches+=("$1"); shift;;
	--rebase)	shift; hasMergeResolutionArg=t; isRebase=t;;
	--ff|--no-ff|--ff-only)
			hasMergeResolutionArg=t; fastForwardArgs=("$1"); shift;;
	--command|-c)	checkCommandArgs+=("$1" "$2"); shift; checkCommands+=(${checkCommands:+&&} "$1"); shift;;
	--bare)		shift; isBare=t;;
	--no-trailing-prompt|--trailing-prompt|--emulate-prompt|--worst-status)  runWithPromptArgs+=("$1"); shift;;

	-[sXm])		mergeArgs+=("$1" "$2"); shift; shift;;
	--@(strategy|strategy-option|gpg-sign)=*)	mergeArgs+=("$1"); shift;;
	--@(strategy|strategy-option|gpg-sign))		mergeArgs+=("$1" "$2"); shift; shift;;

	--)		mergeArgs+=("$1"); shift; break;;
	--*)		mergeArgs+=("$1"); shift;;
	-)		shift; isCheckFromStdin=t; break;;
	-*)		mergeArgs+=("$1"); shift;;
	*)		break;;
    esac
done
if [ "${!#}" = '-' ]; then
    isCheckFromStdin=t
    set -- "${@:1:$(($#-1))}"
fi
if [ "$isCheckFromStdin" ] && [ ${#checkCommands[@]} -gt 0 ]; then
    echo >&2 'ERROR: Cannot combine CHECK-COMMANDLINE from stdin (-) with -c|--command.'
    echo >&2
    printUsage "$0" >&2
    exit 2
fi

branches+=("$@")
if [ ${#branches[@]} -eq 0 ]; then
    echo >&2 'Need (at least one) <branch> to merge!'
    exit 2
fi


canFastForward()
{
    local previousBranch=HEAD
    for branch in "${branches[@]}"
    do
	if [ -n "$(git log --pretty=tformat:%H --max-count 1 "${branch}..$previousBranch")" ]; then
	    # At least one branch has diverged from its predecessor.
	    return 1
	fi
	previousBranch="$branch"
    done
    return 0
}
canRebase()
{
    for branch in "${branches[@]}"
    do
	if [ "$(git log --pretty=tformat:%H --max-count 2 --no-merges "..$branch" | wc -l)" -gt 1 ]; then
	    # At least one branch has more than one non-merge commit.
	    return 1
	fi
    done
    return 0
}

if [ ! "$isContinue" ]; then
    if [ ! "$hasMergeResolutionArg" ]; then
	branchesPlural=es
	branchesSubject=them
	verbPlural=
	if [ ${#branches[@]} -eq 1 ]; then
	    branchesPlural=
	    branchesSubject=it
	    verbPlural=s
	fi

	if canFastForward; then
	    < /dev/tty read -r -N 1 -p "The branch$branchesPlural can be fast-forwarded instead of merged. Fast-forward? (y/n) " choice; echo >/dev/tty
	    [ "$choice" = 'y' ] && fastForwardArgs=(--ff-only)
	elif canRebase; then
	    < /dev/tty read -r -N 1 -p "The branch$branchesPlural only consist$verbPlural of a single commit. Rebase $branchesSubject instead of creating a separate merge commit? (y/n) " choice; echo >/dev/tty
	    [ "$choice" = 'y' ] && isRebase=t
	fi
    fi


    if [ "$isRebase" ]; then
	origRef="$(git-orig-ref)" || exit $?

	for branch in "${branches[@]}"
	do
	    git rebase HEAD "$branch" && git checkout "$origRef" || exit $?
	    git merge --ff-only "$branch" || exit $?
	done
    else
	git merge "${fastForwardArgs[@]:---no-ff}" "${mergeArgs[@]}" "${branches[@]}" || exit $?
    fi
fi


if [ "$isCheckFromStdin" ]; then
    if [ "$isBare" ]; then
	bash -
    else
	runWithPrompt "${runWithPromptArgs[@]}"
    fi
elif [ ${#checkCommands[@]} -gt 0 ]; then
    eval "${checkCommands[@]}"
fi || {
    status=$?
    branchSubject='branches have'; [ ${#branches[@]} -eq 1 ] && branchSubject='the branch has'
    echo >&2 "Checks failed; $branchSubject been merged, but not ${isPush:+pushed or }deleted yet."
    echo >&2 'Correct the problem by amending or additional commits, then invoke'

    [ "$isCheckFromStdin" ] && printf >&2 'echo CHECK-COMMANDLINES | '
    printf >&2 '%q ' "$(basename "$0")" '--continue' ${isBare:+--bare} "${runWithPromptArgs[@]}" "${checkCommandArgs[@]}"
    for branch in "${branches[@]}"; do printf >&2 -- '--branch %q ' "$branch"; done
    [ "$isCheckFromStdin" ] && printf >&2 '-'
    printf >&2 '\n'

    exit $status
}


if [ "$isPush" ]; then
    path="$(git-brname --real-branch-only)" || exit $?
    targetTracks="$(git-tracks 2>/dev/null)"
    targetTrackedRemote="${targetTracks%%/*}"

    if [ "$targetTrackedRemote" = 'origin' ]; then
	# First push to upstream; we usually want to catch up origin to
	# upstream, but keep it at the current state if pushing to upstream
	# failed.
	if git-existsbr "upstream/$path"; then
	    git push upstream "$path" || exit $?
	fi
    fi
    if [ "$targetTrackedRemote" ]; then
	# Push to the tracked remote (usually origin).
	git push "$targetTrackedRemote" || exit $?
    fi
    if [ "$targetTrackedRemote" != 'origin' ]; then
	# Push to origin (if it's different from the tracked remote) last.
	if git-existsbr "origin/$path"; then
	    git push origin "$path" || exit $?
	fi
    fi
fi

status=0
for branch in "${branches[@]}"
do
    tracks="$(git-tracks "$branch" 2>/dev/null)"
    trackedRemote="${tracks%%/*}"
    if [ "$trackedRemote" ]; then
	git-rldeletebr "$trackedRemote" "$branch" || status=$?
    else
	git-deletebr "$branch" || status=$?
    fi
done
exit $status
