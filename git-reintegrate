#!/bin/bash
shopt -qs extglob

printUsage()
{
    cat <<HELPTEXT
Merge / rebase <branch> to the current branch, then delete it from the local
repository as well as a tracked remote (if it exists there).
HELPTEXT
    printf 'Usage: %q %s\n' "$(basename "$1")" '[--push] [--rebase|--ff|--ff-only|--no-ff|<merge-args> ...] -b|--branch <branch> [...] | [--] <branch> [...]'
}

isPush=
isRebase=
typeset -a branches=()
typeset -a fastForwardArgs=()
typeset -a mergeArgs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--push)		shift; isPush=t;;
	--branch|-b)	shift; branches+=("$1"); shift;;
	--rebase)	shift; isRebase=t;;
	--ff|--no-ff|--ff-only)	fastForwardArgs=("$1"); shift;;

	-[sXm])		mergeArgs+=("$1" "$2"); shift; shift;;
	--@(strategy|strategy-option|gpg-sign)=*)	mergeArgs+=("$1"); shift;;
	--@(strategy|strategy-option|gpg-sign))		mergeArgs+=("$1" "$2"); shift; shift;;

	--)		mergeArgs+=("$1"); shift; break;;
	--*)		mergeArgs+=("$1"); shift;;
	-*)		mergeArgs+=("$1"); shift;;
	*)		break;;
    esac
done
branches+=("$@")
if [ ${#branches[@]} -eq 0 ]; then
    echo >&2 'Need (at least one) <branch> to merge!'
    exit 2
fi


if [ "$isRebase" ]; then
    if [ ${#branches[@]} -ne 1 ]; then
	echo >&2 'ERROR: Can only rebase exactly one branch.'
	exit 2
    fi

    git rebase --preserve-merges "${branches[@]}" || exit $?
    mergeArgs=()
    fastForwardArgs=(--ff-only)
fi

git merge "${fastForwardArgs[@]:---no-ff}" "${mergeArgs[@]}" "${branches[@]}" || exit $?

if [ "$isPush" ]; then
    path="$(git-brname)" || exit $?
    targetTracks="$(git-tracks 2>/dev/null)"
    targetTrackedRemote="${targetTracks%%/*}"

    if [ "$targetTrackedRemote" = 'origin' ]; then
	# First push to upstream; we usually want to catch up origin to
	# upstream, but keep it at the current state if pushing to upstream
	# failed.
	if git-existsbr "upstream/$path"; then
	    git push upstream "$path" || exit $?
	fi
    fi
    if [ "$targetTrackedRemote" ]; then
	# Push to the tracked remote (usually origin).
	git push "$targetTrackedRemote" || exit $?
    fi
    if [ "$targetTrackedRemote" != 'origin' ]; then
	# Push to origin (if it's different from the tracked remote) last.
	if git-existsbr "origin/$path"; then
	    git push origin "$path" || exit $?
	fi
    fi
fi

status=0
for branch in "${branches[@]}"
do
    tracks="$(git-tracks "$branch" 2>/dev/null)"
    trackedRemote="${tracks%%/*}"
    if [ "$trackedRemote" ]; then
	git-rldeletebr "$trackedRemote" "$branch" || status=$?
    else
	git deletebr "$branch" || status=$?
    fi
done
exit $status
