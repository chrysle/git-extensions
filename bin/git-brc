#!/bin/bash
shopt -qs globstar # ** matches files and/only (as **/) subdirs recursively.

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[--bare] [-r|-a] [-b|--base <branch>] [<branch-glob>] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
List local branches and their first commit ordered by date of first commit, as
based on the best common ancestors of all branches or the branch passed with
--base <branch>. The branches can be optionally filtered by <branch-glob>.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --long|-l		Also print the author name.
    -r			List remote-tracking branches.
    -a			List both local and remote-tracking branches.
HELPTEXT
}

locality='local'
base=
format='%at	%ai	(%ar)'
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--long|-l)	shift; format="${format/)/, %aN)}";;
	--all|-a)	shift; locality='all';;
	--remote|-r)	shift; locality='remote';;
	--base|-b)	shift; base="$1"; shift;;
	--bare)		shift; format='%at';;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
dirBranchGlob="${1//\*/*/**}"    # As we're doing file system lookup, a branch name glob needs to be converted into a directory hierarchy one in case the branch name contains slashes.
case $locality in
    local)  typeset -a what=("refs/heads/$1" "refs/heads/$dirBranchGlob");;
    all)    typeset -a what=("refs/heads/$1" "refs/heads/$dirBranchGlob" "refs/remotes/$1" "refs/remotes/$dirBranchGlob");;
    remote) typeset -a what=("refs/remotes/$1" "refs/remotes/$dirBranchGlob");;
esac

readarray -t branches < <(git for-each-ref --format='%(refname:short)' "${what[@]}"; printf '\n%d\n' "$?")	# Exit status from the process substitution is lost; return the actual exit status via an appended additional line.
[ ${branches[-1]} -ne 0 ] && exit ${branches[-1]}
unset 'branches[-1]'
[ -z "${branches[-1]}" ] && unset 'branches[-1]'

typeset -a firstCommits=()
for branch in "${branches[@]}"
do
    if [ "$base" ]; then
	mergeBase=$(git merge-base "$branch" "$base") || exit $?
    else
	mergeBase=$(git merge-base --octopus "$branch") || exit $?
    fi
    firstCommit=$(git log --pretty="tformat:$format" "${mergeBase}..${branch}" | tail -n 1)
    if [ -z "$firstCommit" ]; then
	# There's no log output when the merge base is identical to the branch;
	# i.e. there's only one commit on the branch so far. Grab that commit
	# separately; this is easier than first checking with git show-ref
	# whether the hashes are identical.
	firstCommit="$(git log -1 --pretty="tformat:$format" "${branch}")"
    fi
    firstCommits+=("$firstCommit	$branch")
done

# Print the sorted information without the leading Unix timestamp used as the
# sort key.
printf '%s\n' "${firstCommits[@]}" | \
    sort | \
    sed -e 's/^[^\t]*\t//' | \
    column -s $'\t' -t
