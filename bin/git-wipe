#!/bin/bash

printUsage()
{
    cat <<HELPTEXT
Reset HEAD, working copy and index [to <branch>] [for <paths> ... only]. Ensures
that the current branch isn't dirty.
HELPTEXT
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" '[<branch>] [-?|-h|--help]'
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" '[CHECKOUT-ARGS ...] [<branch>] [--] <paths> ...'
}

isForce=
typeset -a gitArgs=()
typeset -a paths=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--force|-f)	shift; isForce=t;;
	--)		shift; paths=("$@"); break;;
	*)		gitArgs+=("$1"); shift;;
    esac
done
# DWIM here: Allow both git wipe FILE1 ... and git wipe <commit> FILE1 ... by
# checking whether the arguments exist as files.
if [ ${#paths[@]} -eq 0 ]; then
    # No files after -- captured yet; need to investigate parsed and
    # remaining args from behind for files.
    gitArgs+=("$@")
    while [ ${#gitArgs[@]} -ne 0 ]
    do
	lastArg="${gitArgs[-1]}"
	[ -e "$lastArg" ] || break

	paths=("$lastArg" "${paths[@]}")
	gitArgs=("${gitArgs[@]:0:${#gitArgs[@]}-1}")
    done
fi

if [ ! "$isForce" ]; then
    if ! git-dirty -- "${paths[@]}"; then
	IFS=' '
	printf >&2 'No uncommitted changes; working copy and index are clean%s.\n' "${paths:+ below }${paths[*]}"
	exit 1
    fi

    echo "Uncommitted changes:"
    git status --porcelain -- "${paths[@]}" | grep -v '^??'

    while :
    do
	</dev/tty read -r -N 1 -p 'Discard these changes? (y/n/diff) ' choice; echo >/dev/tty
	case "$choice" in
	    y) break;;
	    n) exit 1;;
	    d) git diff;;
	esac
    done
fi

if [ ${#paths[@]} -gt 0 ]; then
    # git reset --hard ... <paths>... is not allowed ("fatal: Cannot do hard reset with paths.")
    # The right command is git checkout HEAD <paths>...
    if [ ${#gitArgs[@]} -eq 0 ] || ! git rev-parse --verify --quiet "${gitArgs[-1]}" >/dev/null 2>&1; then
	gitArgs+=(HEAD)
    fi
    exec git checkout "${gitArgs[@]}" -- "${paths[@]}"
fi

exec git reset --hard "${gitArgs[@]}"
