#!/bin/bash

printUsage()
{
    cat <<HELPTEXT
Parse an optional BRANCH given as the last argument and turn it into its
corresponding remote branch for REMOTE. If no BRANCH is given, determine the
remote branch for the current branch instead. Return the other ARGS followed by
the remote branch at the end; with --separate-remote-and-branch as two separate
arguments instead of a single REMOTE/BRANCH.
HELPTEXT
    echo
    printf 'Usage: parsedArguments="$(%q %s)" || exit $?\n       eval "set -- $parsedArguments"\n' "$(basename "$1")" '[--separate-remote-and-branch] REMOTE [ARGS ...] [BRANCH] [-?|-h|--help]'
}
isRemoteAndBranchAsSeparateArguments=
case "$1" in
    --help|-h|-\?)	shift; printUsage "$0"; exit 0;;
    --separate-remote-and-branch)
			shift; isRemoteAndBranchAsSeparateArguments=t;;
esac
remote="${1:?}"; shift

lastArg=; [ $# -gt 0 ] && lastArg="${!#}"
if [ -n "$lastArg" ] && remoteBranch="$(git-remotebr "$remote" "$lastArg" 2>/dev/null)"; then
    set -- "${@:1:$(($#-1))}"
else
    remoteBranch="$(git-remotebr "$remote")" || exit $?
fi

if [ "$isRemoteAndBranchAsSeparateArguments" ]; then
    typeset -a remoteBranchArgs=("${remoteBranch%%/*}" "${remoteBranch#*/}")
else
    typeset -a remoteBranchArgs=("$remoteBranch")
fi

printf '%q ' "$@" "${remoteBranchArgs[@]}"
