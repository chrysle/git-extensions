#!/bin/bash
shopt -qs extglob

printUsage()
{
    cat <<HELPTEXT
Checkout passed <remote-branch>, resetting an existing local branch to the
remote, tracking it if it doesn't yet exist locally, and ensuring that an
existing tracked branch doesn't contradict the request.
HELPTEXT
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" '[--gui|--terminal|--none] [<checkout-args> ...] <remote-branch> [-?|-h|--help]'
}
logArg=
case "$1" in
    --help|-h|-\?)	shift; printUsage "$0"; exit 0;;
    --@(gui|terminal|none))
			logArg="$1"; shift;;
esac
if [ $# -eq 0 ]; then
    echo 'ERROR: No <remote-branch> passed!'
    echo
    printUsage "$0"
    exit 2
fi >&2
remoteBranch="${!#}"; shift
[ $# -eq 0 ] && set -- || set -- "${@:1:$(($#-1))}"
remote="${remoteBranch%%/*}"
branch="${remoteBranch#*/}"
if [ -z "$remote" -o -z "$branch" ]; then
    printf 'ERROR: Not a <remote-branch>: %s\n' "$remoteBranch"
    exit 2
fi >&2

record=
if git-existsbr "$branch"; then
    trackedRemoteBranch="$(git-tracks "$branch" 2>/dev/null)"
    if [ -z "$trackedRemoteBranch" ]; then
	: # Fine; we're tracking nothing yet.
    elif [ "$trackedRemoteBranch" = "$remoteBranch" ]; then
	: # Fine; we're already tracking the same remote branch.
    else
	trackedRemote="${trackedRemoteBranch%%/*}"
	trackedBranch="${trackedRemoteBranch#*/}"
	if [ "$trackedBranch" != "$branch" ]; then
	    printf >&2 'ERROR: An existing local branch %s is already tracking a differently named remote branch %s; will not switch to %s.\n' "$branch" "$trackedRemoteBranch" "$remoteBranch"
	    exit 1
	elif [ "$trackedRemote" != "$remote" ]; then
	    printf >&2 'Note: The local branch is already tracking the corresponding branch in %s.\n' "$trackedRemote"
	fi
    fi

    [ "$logArg" = --none ] || record="$(git-logdelta $logArg --branch "$branch" --record)"

    git checkout "$@" -B "$branch" "$remoteBranch" || exit $?
else
    if [ "$logArg" != --none ]; then
	# Show the log of the entire branch as this is a new local checkout.
	branchBase="$(git brbase "$remoteBranch" 2>/dev/null)"
	[ -n "$branchBase" ] && record="$(git-logdelta $logArg --branch "$branchBase" --record)"
    fi

    git checkout "$@" --track -b "$branch" "$remoteBranch" || exit $?
fi
[ -z "$record" ] || git-logdelta $logArg $logRecursionArg --from-record "$record"
