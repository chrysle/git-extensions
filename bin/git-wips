#!/bin/bash
set -o pipefail
shopt -qs nullglob

: ${GIT_WIPS_DOWNSTREAM_BRANCHES_IGNORE_PATTERN='stable'}
: ${GIT_WIPS_CHANGELOG_FILENAME:=CHANGELOG.md}

printUsage()
{
    cat <<HELPTEXT
Test whether the working copy has either:
- dirty:    uncommitted changes
- private:  unversioned files (that are not ignored)
- stashed:  recorded local changes that have been stashed away
- noremote: no remotes have been defined yet; the repository only exists locally
- outgoing: where not all commits (on the current branch) have already been
	    pushed to origin
- incoming: where the current branch misses commits that have been fetched and
	    exist in origin
- fallenbehind:
	    differences in the changelog document exist in upstream
- behind:   where the current branch misses commits that have been fetched and
	    exist in upstream
- behindtags:
	    where the working copy has checked out a tag and there are upstream
	    branch(es) that have more recent tags
- wipcommit:where the last commit had "WIP:" in the message summary
- nonmaster:a branch different from the master branch (or the base branch if
	    defined) is checked out
- downstreambranches:
	    a branch that only exists in origin, but not upstream; may represent
	    concurrent work or a pull request
- inactivefork:
	    my GitHub clone is up-to-date with upstream, has no non-master
	    branches, and therefore can be archived (made read-only).
Individual checks can be selected (from a baseline of no checks) via +name /
deselected (from all checks on offer) via -name.
HELPTEXT
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-v|--verbose] [-q|--quiet|--color=(always|auto|never)|--no-color] [(+|-)(dirty|private|stashed|noremote|outgoing|incoming|fallenbehind|behind|behindtags|wipcommit|nonmaster|downstreambranches|inactivefork) ...] [-?|-h|--help]'
}
typeset -a colorArg=()
typeset -a gitColorConfigArg=()
isVerbose=
case "$1" in
    --help|-h|-\?)	shift; printUsage "$0"; exit 0;;
    --no-color|--color=*)
			colorArg=("$1"); shift;;
    --color)		colorArg=("$1" "$2"); shift; shift;;
    --verbose|-v)	shift; isVerbose=t;;
    --quiet|-q)		shift; exec 1>/dev/null;;
esac
if isNeedColorArgumentWhenPiping "${colorArg[@]}"; then
    colorArg=('--color=always')
else
    colorArg=('--color=never')
    gitColorConfigArg=(-c 'color.status=false')
fi

isFirst=t
declare -A checks=([dirty]=t [private]=t [stashed]=t [noremote]=t [outgoing]=t [incoming]=t [fallenbehind]=t [behind]=t [behindtags]=t [wipcommit]=t [nonmaster]=t [downstreambranches]=t [inactivefork]=t)
while [ $# -gt 0 ]
do
    case "$1" in
	+*) [ "$isFirst" ] && checks=()
	    checks["${1:1}"]=t
	    shift
	    ;;
	-[^-]?*)
	    unset "checks[${1:1}]"
	    shift
	    ;;
	-*) { echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)  printUsage "$0" >&2; exit 2;;
    esac
    isFirst=
done

isSubsequentCheck=
: ${CLEAR_PREVIOUS_LINE=[1F[0K}
considerCheck()
{
    local check="${1:?}"; shift
    [ "${checks[$check]}" ] || return 1

    if [ "$isVerbose" ]; then
	printf >/dev/tty '%sChecking %s...\n' "${isSubsequentCheck:+$CLEAR_PREVIOUS_LINE}" "$check"
	isSubsequentCheck=t
    fi

    return 0
}

considerCheck dirty && \
    if git dirty; then git "${gitColorConfigArg[@]}" st; exit 0; fi

findPrivateFiles()
{
    local IFS=$'\n'
    readarray -t privateFiles < <(git-lsprivate)
    [ ${#privateFiles[@]} -eq 0 ] && return 1
    printf 'Unversioned file: %s\n' "${privateFiles[@]}"
}
considerCheck private && \
    if findPrivateFiles; then exit 0; fi

considerCheck stashed && \
    if git rev-parse --verify --quiet refs/stash >/dev/null; then git stash list; exit 0; fi

considerCheck noremote && \
    if ! git existsremote; then echo "Local-only repository; no remotes defined yet."; exit 0; fi

considerCheck outgoing && \
    if git existsremote origin && git remotebr origin >/dev/null 2>&1 && git ooutlgn "${colorArg[@]}" | headtail --separator $'\t\t\t\t\t[...]' | outputAndPrintf 'Outgoing to origin:\n'; then exit 0; fi

considerCheck incoming && \
    if git existsremote origin && git remotebr origin >/dev/null 2>&1 && git oinlgn "${colorArg[@]}" | headtail --separator $'\t\t\t\t\t[...]' | outputAndPrintf 'Incoming from origin:\n'; then exit 0; fi

printChangelogDifferences()
{
    local root; root="$(git root 2>/dev/null)" || return 1
    local changelogFilespec="${root}/${GIT_WIPS_CHANGELOG_FILENAME}"
    if [ ! -r "$changelogFilespec" ]; then
	typeset -a changelogs=("$root"/*/"${GIT_WIPS_CHANGELOG_FILENAME}")
	[ ${#changelogs[@]} -gt 0 ] && changelogFilespec="${changelogs[0]}" || return 1
    fi

    local remoteBranch; remoteBranch="$(git-remotebr upstream 2>/dev/null)" || return 1
    git diff -R "${colorArg[@]}" "$remoteBranch" -- "$changelogFilespec" | outputAndPrintf 'Behind changes in upstream:\n'
}
considerCheck fallenbehind && \
    if git existsremote upstream && git remotebr upstream >/dev/null 2>&1 && printChangelogDifferences; then exit 0; fi

considerCheck behind && \
    if git existsremote upstream && git remotebr upstream >/dev/null 2>&1 && git uinlgn "${colorArg[@]}" | headtail --separator $'\t\t[... use "git uinl[o]g" for the full list ...]' | outputAndPrintf 'Behind upstream:\n'; then exit 0; fi

considerCheck behindtags && \
    git existsremote upstream && \
	tagName="$(git istagged --print)" && \
	if GIT_BRREFDO_BRANCH_COMMAND='git ubr' git-brrefdo --no-header --no-pager --quiet --yes -- git lgtaggeduntiltag "$tagName" --color=always {} | \
	    uniqueStable | outputAndPrintf 'Behind these tags in upstream:\n'; then exit 0; fi

considerCheck wipcommit && \
    if git l --max-count=1 "${colorArg[@]}" | grep '\(^\| \)WIP: '; then exit 0; fi

considerCheck nonmaster && \
    if branchName="$(git-brname --real-branch-only 2>/dev/null)"; [ -n "$branchName" -a "$branchName" != "$(git-mbr)" -a "$branchName" != "$(git-nbr 2>/dev/null)" ]; then printf 'On branch %s\n' "$branchName"; exit 0; fi

findDownstreamBranches()
{
    typeset -a originBranches=()
    readarray -t originBranches < <(git obr | sed -e 's/^ \+//' ${GIT_WIPS_DOWNSTREAM_BRANCHES_IGNORE_PATTERN:+-e "/^origin\\/\\(${GIT_WIPS_DOWNSTREAM_BRANCHES_IGNORE_PATTERN}\\)\$/d"})
    local originBranch status=1; for originBranch in "${originBranches[@]}"
    do
	if ! git existsbr "${originBranch/#origin/upstream}"; then
	    printf 'origin-only: %s\n' "${originBranch/#origin\//}"
	    status=0
	fi
    done
    return $status
}
considerCheck downstreambranches && \
    if git existsremote origin && git existsremote upstream && findDownstreamBranches; then exit 0; fi

findInactiveFork()
{
    local masterBranch; masterBranch="$(git-mbr)" || return 3
    git obr | grep -v --quiet --fixed-strings --line-regexp "origin/$masterBranch" && return 1 # There still are non-master origin branches.
    git diff --quiet "upstream/$masterBranch" "origin/$masterBranch" || return 1    # origin and upstream have diverged.
    hub-isarchived && return 1	# origin has already been archived (made read-only).

    echo 'origin has no active branches, is up-to-date with upstream, and can be archived.'
}
considerCheck inactivefork && \
    if git existsremote origin && git existsremote upstream && findInactiveFork; then exit 0; fi

[ "$isVerbose" ] && printf >/dev/tty %s "$CLEAR_PREVIOUS_LINE"
exit 1
