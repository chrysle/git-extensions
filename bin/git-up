#!/bin/bash
shopt -qs extglob

# Source:
#   https://stackoverflow.com/questions/30208928/can-git-pull-automatically-stash-and-pop-pending-changes
#   https://github.com/aanand/git-up

printUsage()
{
    local action='Pull and rebase'
    if [ "$GIT_UP_NO_UPDATE" ]; then
	action='Only fetch changes (no update of local branches)'
    elif [ "$GIT_UP_FETCH" ]; then
	action='Fetch and rebase changes'
    elif [ "$GIT_UP_REBASE" ]; then
	action='Rebase changes'
    fi

    cat <<HELPTEXT
$action in ${remote:-REMOTE}, and show a log of the changes.
HELPTEXT
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" "[--gui|--terminal|--none] [-q|--quiet] ${remote:-REMOTE} [PULL/REBASE-ARGS ...] [-?|-h|--help]"
}

getRemoteBranch()
{
    if [ $# -gt 0 ] && git-existsbr "${!#}"; then
	git-remotebr "${remote:?}" "${!#}"
    else
	git-remotebr "${remote:?}"
    fi
}

remote=
typeset -a logDeltaArgs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--@(gui|terminal|none|quiet))
			logDeltaArgs+=("$1"); shift;;
	-[q])
			logDeltaArgs+=("$1"); shift;;
	--launch)	break;;
	*)		if [ -z "$remote" ]; then
			    remote="$1"; shift
			else
			    break
			fi
			;;
    esac
done
if [ "$1" = '--launch' ]; then
    shift
else
    readonly scriptFilespec="${BASH_SOURCE[0]}"
    export $(compgen -v)	# Export any script variables so that they are available to the callee, too.

    if [ "$GIT_UP_NO_UPDATE" ] && [ "$GIT_UP_FETCH" ]; then
	if remoteBranch="$(getRemoteBranch "$@")"; then
	    # The delta needs to be done on the remote branch, as there'll be no
	    # update of local branches / HEAD.
	    logDeltaArgs+=(--branch "$remoteBranch")
	else
	    [ "${logDeltaArgs[*]}" = '--none' ] || echo >&2 "Warning: Could not determine corresponding ${remote:-REMOTE} branch, no logging possible."
	    logDeltaArgs=(--none)
	fi
    fi

    exec git-logdelta "${logDeltaArgs[@]}" -- "$scriptFilespec" "${remote:?}" --launch "$@"
fi

GIT_VERSION="$(git --version 2>/dev/null)"
# --rebase-merges and --rebase=merges is Git 2.18 and later.
typeset -a gitRebaseMergesArg=(--rebase-merges)
typeset -a gitPullRebaseMergesArg=(--rebase=merges)
# --autostash is Git 2.9 and later.
# -c rebase.autoStash=true is Git 2.6 and later.
typeset -a gitAutoStashGitArg=()
typeset -a gitAutoStashPullOrRebaseArg=(--autostash)
if versionCompare "$GIT_VERSION" -lt 2.18 2>/dev/null; then
    gitRebaseMergesArg=(--preserve-merges)
    gitPullRebaseMergesArg=(--rebase=preserve)
    if versionCompare "$GIT_VERSION" -lt 2.9 2>/dev/null; then
	gitAutoStashGitArg=(-c rebase.autoStash=true)
	gitAutoStashPullOrRebaseArg=()
    fi
fi

if [ "$GIT_UP_FETCH" ]; then
    git fetch "$remote" || exit $?
fi

# Here, merges typically happen from the master / base branch to pick up
# changes. If we need to rebase a (feature) branch during pulling, that means
# that there was (accidentally?) concurrent development. Here, we still like to
# keep the merges intact; the decision to flatten them or not should only come
# when reintegrating the branch (namely, whether to rebase or merge).
if [ "$GIT_UP_NO_UPDATE" ]; then
    :
elif [ "$GIT_UP_REBASE" ]; then
    remoteBranch="$(getRemoteBranch "$@")" || exit $?
    git "${gitAutoStashGitArg[@]}" rebase "${gitAutoStashPullOrRebaseArg[@]}" "${gitRebaseMergesArg[@]}" "${@:1:$(($#-1))}" "$remoteBranch" || exit $?
else
    git "${gitAutoStashGitArg[@]}" pull "${gitAutoStashPullOrRebaseArg[@]}" "${gitPullRebaseMergesArg[@]}" "$remote" "$@" || exit $?
fi
