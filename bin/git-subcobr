#!/bin/bash
shopt -qs extglob

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[--query] [--recursive] [--local|--remote|--update [--gui|--terminal|--none]] [-f|--force] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
For each configured submodule, check out the branch specified in the .gitmodules
file (or master).
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --query		Confirm for each submodule whether it should be checked
			out, reset to what the superproject has recorded, or
			left as-is.
    --recursive		Also check out branches in nested submodules.
    --local		Check out the local branch.
    --remote		Update the local branch to the tracked remote (without
			logging).
    --update		Update the local branch to the tracked remote, and show
			a log of the changes between the previous (detached)
			checkout and the remote branch. This is the default.
    --force|-f		Proceed even if the index or the working tree differs
			from HEAD. This is used to throw away local changes.
HELPTEXT
}

typeset -a allargs=("$@")
isQuery=
isRecursive=
action=update
logArg=
forceArg=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--query)	shift; isQuery=t;;
	--recursive)	shift; isRecursive=t;;
	--local)	shift; action=checkoutLocal;;
	--remote)	shift; action=update; logArg=--none;;
	--update)	shift; action=update;;
	--@(gui|terminal|none))
			logArg="$1"; shift;;
	--force|-f)	forceArg="$1"; shift;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -ne 0 ]; then
    printUsage "$0" >&2
    exit 2
fi

checkoutLocal()
{
    local branch="${1:?}"; shift
    git checkout $forceArg "$branch"
}

update()
{
    local branch="${1:?}"; shift
    local remote; remote="$(git-trackedremote "$branch")" || return $?
    local remoteRef; remoteRef="$(git-commitid "${remote}/${branch}")" || return $?
    local originalRevision; originalRevision="$(git rev-parse "$branch" 2>/dev/null)"
    git update-ref -m "subcobr: move $branch to ${remote}/${branch}" "refs/heads/$branch" "$remoteRef" || :	# Still checkout the local branch even if the forwarding did not work.
    git checkout $forceArg "$branch" || exit $?

    [ "$logArg" = --none ] && return
    git-logdelta $logArg --from "$originalRevision"
}

typeset -A submoduleBranches=()
while IFS=$'\t' read -r submodule branch
do
    case "$branch" in
	# A special value of . is used to indicate that the name of the branch
	# in the submodule should be the same name as the current branch in the
	# current repository.
	.)  branch="$(git-brname --real-branch-only)" || exit $?;;

	# "git submodule update --remote" defaults to master.
	'') branch='master';;
    esac

    submoduleBranches["$submodule"]="$branch"
done < <(git config --blob HEAD:.gitmodules -l | awk -F [=.] '$3 == "path" { path[$2] = $4 } $3 == "branch" { branch[$2] = $4 } END { for (submodule in branch) { print path[submodule] "\t" branch[submodule] } }')
if [ ${#submoduleBranches[@]} -eq 0 ]; then
    echo >&2 'No submodules'
    exit 99
fi

status=0
for submodule in "${!submoduleBranches[@]}"
do
    if [ "$isQuery" ]; then
	choice="$(userchoiceFromList --no-cancel --question "${prefix}${submodule}" \
	    'check out' 'reset to superproject' 'leave as-is')"
	case "$choice" in
	    'check out')
		# This is the default action.
		;;
	    'reset to superproject')
		git checkout $forceArg HEAD -- "$submodule" || status=$?;;
	    'leave as-is')
		continue;;
	    *)	printf >&2 'ASSERT: Invalid choice: %s\n' "$choice"; exit 3;;
	esac
    fi

    ( set -e
	cd "$submodule"
	$action "${submoduleBranches["$submodule"]}"
	[ ! "$isRecursive" ] || : # TODO: recursion
    ) || status=$?
done
exit $status
