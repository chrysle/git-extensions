#!/bin/bash
shopt -qs extglob

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[--status|--query|--all] [--recursive] [--existing|--local|--remote|--update [--gui|--terminal|--none]] [-f|--force] [--] [SUBMODULE ...] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
For each configured submodule / passed SUBMODULE(s), check out the branch
specified in the .gitmodules file (or master).
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --status		Show the current status of all / the passed submodules
			without doing any checkouts.
    --query		Confirm for each submodule whether it should be checked
			out, reset to what the superproject has recorded, or
			left as-is.
    --all		Check out all defined submodules without querying.
			By default, the status will be shown unless at least one
			SUBMODULE is passed.
    --recursive		Also check out branches in nested submodules.
    --existing		Check out an existing local branch; don't touch
			submodules that don't have such a branch.
			This is the default.
    --local		Check out the local branch.
    --remote		Update the local branch to the tracked remote (without
			logging).
    --update		Update the local branch to the tracked remote, and show
			a log of the changes between the previous (detached)
			checkout and the remote branch.
    --force|-f		Proceed even if the index or the working tree differs
			from HEAD. This is used to throw away local changes.
HELPTEXT
}

typeset -a recursiveArgs=()
action=
isRecursive=
checkoutAction=checkoutExisting
checkoutWhat='update to tracked remote'
logArg=
forceArg=
prefix=
noOpStatus=99
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--@(status|query|all))
			recursiveArgs+=("$1"); action="${1#--}"; shift;;
	--recursive)	recursiveArgs+=("$1"); shift; isRecursive=t;;
	--existing)	recursiveArgs+=("$1"); shift; checkoutAction=checkoutExisting; checkoutWhat='check out existing';;
	--local)	recursiveArgs+=("$1"); shift; checkoutAction=checkoutLocal; checkoutWhat='check out / create';;
	--remote)	recursiveArgs+=("$1"); shift; checkoutAction=update; checkoutWhat='update to tracked remote'; logArg=--none;;
	--update)	recursiveArgs+=("$1"); shift; checkoutAction=update; checkoutWhat='update to tracked remote';;
	--@(gui|terminal|none))
			recursiveArgs+=("$1")
			logArg="$1"; shift;;
	--force|-f)	recursiveArgs+=("$1"); forceArg="$1"; shift;;
	--prefix)	recursiveArgs+=("$1" "$2"); shift; prefix+="$1"; noOpStatus=0; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
typeset -A selectedSubmodules=()
for submodule
do
    : ${action:=all}
    selectedSubmodules["${submodule%/}"]=t
done
: ${action:=status}

getSubmoduleStatus()
{
    local submodule="${1:?}"; shift
    local isPrependAdditionalInformation="$1"; shift

    local subhash="$(git-subhash --short "$submodule" 2>/dev/null)"
    (
	cd "$submodule" || exit 3

	currentBranchName="$(git-brname --real-branch-only 2>/dev/null)"
	toBranchAction='check out to local branch'
	if git-existsbr "${submoduleBranches["$submodule"]}"; then
	    hasLocalBranch=t
	    remote="$(git-trackedremote "${submoduleBranches["$submodule"]}" 2>/dev/null)" || remote='origin'
	    toBranchAction='switch to'
	else
	    hasLocalBranch=
	    remote='origin'
	fi
	hasRemoteBranch=; git-existsbr "${remote}/${submoduleBranches["$submodule"]}" && hasRemoteBranch=t
	[ "$hasRemoteBranch" ] || toBranchAction='create new local branch'

	[ "$isPrependAdditionalInformation" ] && printf '%s\n' "$hasLocalBranch" "$hasRemoteBranch"

	if [ "$currentBranchName" = "${submoduleBranches["$submodule"]}" ]; then
	    updateHint=; [ "$checkoutAction" = update ] && [ "$hasRemoteBranch" ] && updateHint='; would update'
	    printf "%-${submoduleWidth}s already on %s%s\\n" "${prefix}${submodule}" "$currentBranchName" "$updateHint"
	elif [ -n "$currentBranchName" ]; then
	    printf "%-${submoduleWidth}s on %s; would %s %s\\n" "${prefix}${submodule}" "$currentBranchName" "$toBranchAction" "${submoduleBranches["$submodule"]}"
	else
	    currentRev="$(git rev-parse --short HEAD)" || exit $?
	    if [ "$subhash" = "$currentRev" ]; then
		printf "%-${submoduleWidth}s detached checkout of %s; would %s %s\\n" "${prefix}${submodule}" "$currentRev" "$toBranchAction" "${submoduleBranches["$submodule"]}"
	    else
		printf "%-${submoduleWidth}s detached checkout of %s != %s; would %s %s\\n" "${prefix}${submodule}" "$currentRev" "$subhash" "$toBranchAction" "${submoduleBranches["$submodule"]}"
	    fi
	fi
    )
}

checkoutNew()
{
    local branch="${1:?}"; shift

    # > The remote used is branchâ€™s remote (branch.<name>.remote), defaulting to
    # > origin.
    # As we don't have a local branch yet, that's origin for sure.
    local remoteBranch="origin/$branch"

    if git-existsbr "$remoteBranch"; then
	git checkout $forceArg --track -b "$branch" "$remoteBranch"
    else
	git checkout $forceArg -b "$branch"
    fi
}

checkoutExisting()
{
    local branch="${1:?}"; shift
    if git-existsbr "$branch"; then
	git checkout $forceArg "$branch"
    else
	printf >&2 '%s: Skipping because no branch %s exists.\n' "${prefix}${submodule}" "$branch"
    fi
}

checkoutLocal()
{
    local branch="${1:?}"; shift
    if git-existsbr "$branch"; then
	git checkout $forceArg "$branch"
    else
	checkoutNew "$branch"
    fi
}

update()
{
    local branch="${1:?}"; shift
    local remote; remote="$(git-trackedremote "$branch")" || return $?
    local remoteRef; remoteRef="$(git-commitid "${remote}/${branch}")" || return $?

    local logRecursionArg='--submodule recurse'; [ "$isRecursive" ] && logRecursionArg=	# When we recursively check out, we'll show the logs of nested submodules. But if not, let logdelta do the recursion to see what changed in submodules, too.
    local record; [ "$logArg" = --none ] || record="$(git-logdelta $logArg $logRecursionArg --record)"

    if [ "$(git-brname --real-branch-only 2>/dev/null)" = "$branch" ]; then
	# Already on that branch, reset it.
	git reset ${forceArg:+--hard} "$remoteRef" || return $?
    elif git-existsbr "$branch"; then
	# Move the branch to the revision of the tracked branch, then check it
	# out.
	git update-ref -m "subcobr: move $branch to ${remote}/${branch}" "refs/heads/$branch" "$remoteRef" || :	# Still checkout the local branch even if the forwarding did not work.
	git checkout $forceArg "$branch" || return $?
    else
	checkoutNew "$branch"
	return	# No changes to log here.
    fi

    [ -z "$record" ] || git-logdelta $logArg $logRecursionArg --from-record "$record"
}

unset currentBranchName
let submoduleWidth=0
typeset -A submoduleBranches=()
while IFS=$'\t' read -r submodule branch
do
    case "$branch" in
	# A special value of . is used to indicate that the name of the branch
	# in the submodule should be the same name as the current branch in the
	# current repository.
	.)  [ -n "${currentBranchName+t}" ] || currentBranchName="$(git-brname --real-branch-only 2>/dev/null)"
	    branch="${currentBranchName:-master}"
	    ;;

	# "git submodule update --remote" defaults to master.
	'') branch='master';;
    esac

    submoduleBranches["$submodule"]="$branch"

    [ $submoduleWidth -lt ${#submodule} ] && submoduleWidth=${#submodule}
done < <(git config --file .gitmodules -l 2>/dev/null | awk -F = '{ key = $1; $1 = ""; sub(OFS, ""); submodule = gensub(/^submodule\.|\.[^.]+$/, "", "g", key) } key ~ /.path$/ { path[submodule] = $0; } key ~ /.branch$/ { branch[submodule] = $0; } END { for (submodule in path) { print path[submodule] "\t" branch[submodule] } }')
if [ ${#submoduleBranches[@]} -eq 0 ]; then
    echo >&2 'No submodules'
    exit $noOpStatus
fi

typeset -A uninitializedSubmodules=()
while IFS=$'\n' read -r submodule
do
    uninitializedSubmodules["$submodule"]=t
done < <(git-submodule-uninitialized --print)	# Don't recurse, as we're matching against the direct submodules from .gitmodules; further recursions will check their own nested submodules.

status=
readarray -t submoduleList < <(printf '%s\n' "${!submoduleBranches[@]}" | sort)
for submodule in "${submoduleList[@]}"
do
    [ ${#selectedSubmodules[@]} -eq 0 ] || [ "${selectedSubmodules["$submodule"]}" ] || continue

    case "$action" in
	status)
	    if [ "${uninitializedSubmodules["$submodule"]}" ]; then
		printf "%-${submoduleWidth}s hasn't been initialized yet\\n" "${prefix}${submodule}"
		status=1
		continue
	    fi

	    getSubmoduleStatus "$submodule" && : ${status:=0} || status=$?

	    continue
	    ;;
	query)
	    if [ "${uninitializedSubmodules["$submodule"]}" ]; then
		choice="$(userchoiceFromList --no-cancel --question "${prefix}${submodule} hasn't been initialized yet" \
		    'initialize now' 'skip' 'abort')"
		case "$choice" in
		    'initialize now')
			git submodule update --init --recursive -- "$submodule" || { status=$?; continue; }
			;;
		    'skip')
			continue;;
		    'abort')
			exit 1;;
		    *)	printf >&2 'ASSERT: Invalid choice: %s\n' "$choice"; exit 3;;
		esac
	    fi

	    {
		IFS=$'\n' read -r hasLocalBranch
		IFS=$'\n' read -r hasRemoteBranch
		IFS=$'\n' read -r submoduleStatus
	    } < <(submoduleWidth=0 getSubmoduleStatus "$submodule" t)
	    choice="$(userchoiceFromList --no-cancel --question "$submoduleStatus" \
		"$checkoutWhat" 'reset to superproject' 'leave as-is')"
	    case "$choice" in
		"$checkoutWhat")
		    # This is the default action.
		    ;;
		'reset to superproject')
		    git checkout $forceArg HEAD -- "$submodule" && : ${status:=0} || status=$?
		    continue
		    ;;
		'leave as-is')
		    : ${status:=0}
		    continue
		    ;;
		*)  printf >&2 'ASSERT: Invalid choice: %s\n' "$choice"; exit 3;;
	    esac
	    ;;
	all)
	    if [ "${uninitializedSubmodules["$submodule"]}" ]; then
		printf "%s hasn't been initialized yet\\n" "${prefix}${submodule}"
		exit 1
	    fi
	    ;;
	*)  printf >&2 'ASSERT: Invalid action: %s\n' "$action"; exit 3;;
    esac

    (
	cd "$submodule" || exit 3

	$checkoutAction "${submoduleBranches["$submodule"]}" || exit $?

	if [ "$isRecursive" ]; then
	    typeset -a selectedNestedSubmodules=()
	    for s in "${!selectedSubmodules[@]}"
	    do
		[[ "$s" =~ ^"$submodule"/(.*)$ ]] && \
		    selectedNestedSubmodules+=("${BASH_REMATCH[1]}")
	    done
	    "${BASH_SOURCE[0]}" "${recursiveArgs[@]}" --prefix "${submodule}/" -- "${selectedNestedSubmodules[@]}"
	fi
    ) && : ${status:=0} || status=$?
done
exit ${status:-$noOpStatus}
