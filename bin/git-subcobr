#!/bin/bash
shopt -qs extglob

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[--query] [--recursive] [--local|--remote|--update [--gui|--terminal|--none]] [-f|--force] [--] [SUBMODULE ...] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
For each configured submodule / passed SUBMODULE(s), check out the branch
specified in the .gitmodules file (or master).
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --query		Confirm for each submodule whether it should be checked
			out, reset to what the superproject has recorded, or
			left as-is.
    --recursive		Also check out branches in nested submodules.
    --local		Check out the local branch.
    --remote		Update the local branch to the tracked remote (without
			logging).
    --update		Update the local branch to the tracked remote, and show
			a log of the changes between the previous (detached)
			checkout and the remote branch. This is the default.
    --force|-f		Proceed even if the index or the working tree differs
			from HEAD. This is used to throw away local changes.
HELPTEXT
}

typeset -a recursiveArgs=()
isQuery=
isRecursive=
action=update
logArg=
forceArg=
prefix=
noOpStatus=99
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--query)	recursiveArgs+=("$1"); shift; isQuery=t;;
	--recursive)	recursiveArgs+=("$1"); shift; isRecursive=t;;
	--local)	recursiveArgs+=("$1"); shift; action=checkoutLocal;;
	--remote)	recursiveArgs+=("$1"); shift; action=update; logArg=--none;;
	--update)	recursiveArgs+=("$1"); shift; action=update;;
	--@(gui|terminal|none))
			recursiveArgs+=("$1")
			logArg="$1"; shift;;
	--force|-f)	recursiveArgs+=("$1"); forceArg="$1"; shift;;
	--prefix)	recursiveArgs+=("$1" "$2"); shift; prefix+="$1"; noOpStatus=0; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
typeset -A selectedSubmodules=()
for submodule
do
    selectedSubmodules["${submodule%/}"]=t
done

checkoutLocal()
{
    local branch="${1:?}"; shift
    git checkout $forceArg "$branch"
}

update()
{
    local branch="${1:?}"; shift
    local remote; remote="$(git-trackedremote "$branch")" || return $?
    local remoteRef; remoteRef="$(git-commitid "${remote}/${branch}")" || return $?

    local logRecursionArg='--submodule recurse'; [ "$isRecursive" ] && logRecursionArg=	# When we recursively check out, we'll show the logs of nested submodules. But if not, let logdelta do the recursion to see what changed in submodules, too.
    local record; [ "$logArg" = --none ] || record="$(git-logdelta $logArg $logRecursionArg --record)"

    if [ "$(git-brname --real-branch-only 2>/dev/null)" = "$branch" ]; then
	# Already on that branch, reset it.
	git reset ${forceArg:+--hard} "$remoteRef" || return $?
    else
	# Move the branch to the revision of the tracked branch, then check it
	# out.
	git update-ref -m "subcobr: move $branch to ${remote}/${branch}" "refs/heads/$branch" "$remoteRef" || :	# Still checkout the local branch even if the forwarding did not work.
	git checkout $forceArg "$branch" || return $?
    fi

    [ -z "$record" ] || git-logdelta $logArg $logRecursionArg --from-record "$record"
}

typeset -A submoduleBranches=()
while IFS=$'\t' read -r submodule branch
do
    case "$branch" in
	# A special value of . is used to indicate that the name of the branch
	# in the submodule should be the same name as the current branch in the
	# current repository.
	.)  branch="$(git-brname --real-branch-only)" || exit $?;;

	# "git submodule update --remote" defaults to master.
	'') branch='master';;
    esac

    submoduleBranches["$submodule"]="$branch"
done < <(git config --blob HEAD:.gitmodules -l | awk -F [=.] '$3 == "path" { path[$2] = $4 } $3 == "branch" { branch[$2] = $4 } END { for (submodule in branch) { print path[submodule] "\t" branch[submodule] } }')
if [ ${#submoduleBranches[@]} -eq 0 ]; then
    echo >&2 'No submodules'
    exit $noOpStatus
fi

status=
for submodule in "${!submoduleBranches[@]}"
do
    [ ${#selectedSubmodules[@]} -eq 0 ] || [ "${selectedSubmodules["$submodule"]}" ] || continue

    if [ "$isQuery" ]; then
	choice="$(userchoiceFromList --no-cancel --question "${prefix}${submodule}" \
	    'check out' 'reset to superproject' 'leave as-is')"
	case "$choice" in
	    'check out')
		# This is the default action.
		;;
	    'reset to superproject')
		git checkout $forceArg HEAD -- "$submodule" && : ${status:=0} || status=$?
		continue
		;;
	    'leave as-is')
		: ${status:=0}
		continue
		;;
	    *)	printf >&2 'ASSERT: Invalid choice: %s\n' "$choice"; exit 3;;
	esac
    fi

    ( set -e
	cd "$submodule"
	$action "${submoduleBranches["$submodule"]}"

	if [ "$isRecursive" ]; then
	    typeset -a selectedNestedSubmodules=()
	    for s in "${!selectedSubmodules[@]}"
	    do
		[[ "$s" =~ ^"$submodule"/(.*)$ ]] && \
		    selectedNestedSubmodules+=("${BASH_REMATCH[1]}")
	    done
	    "${BASH_SOURCE[0]}" "${recursiveArgs[@]}" --prefix "${submodule}/" -- "${selectedNestedSubmodules[@]}"
	fi
    ) && : ${status:=0} || status=$?
done
exit ${status:-$noOpStatus}
