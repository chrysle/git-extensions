#!/bin/bash
set -o noglob

printUsage()
{
    cat <<HELPTEXT
Execute GIT-COMMAND with modified (staged and unstaged) files appended.
HELPTEXT
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-c ...] GIT-COMMAND [<git-command-args> ...] [-?|-h|--help]'
}

if [ $# -eq 0 ]; then
    echo >&2 'ERROR: No GIT-COMMAND passed.'
    exit 2
fi

readarray -t stfiles < <(eval "${GIT_STFILES_COMMAND:-git-stfiles}"; printf '\n%d\n' "$?")	# Exit status from the process substitution is lost; return the actual exit status via an appended additional line.
[ ${stfiles[-1]} -ne 0 ] && exit ${stfiles[-1]}
unset "stfiles[$((${#stfiles[@]}-1))]"
[ -z "${stfiles[-1]}" ] && unset "stfiles[$((${#stfiles[@]}-1))]"
if [ ${#stfiles[@]} -eq 0 ]; then
    echo >&2 'ERROR: No files.'
    exit 1
fi

typeset -a gitCommand=()
case "$1" in
    --help|-h|-\?)  shift; printUsage "$0"; exit 0;;
    [^-]*-command)  gitCommand+=("$1"); shift
		    while [ $# -ne 0 ]
		    do
			case "$1" in
			    --)		break;;
			    -*)		gitCommand+=("$1"); shift;;
			    *)		gitCommand+=("$1"); shift; break;;
			esac
		    done
		    ;;
    *)		    while [ $# -ne 0 ]
		    do
			case "$1" in
			    -c) gitCommand+=("$1" "$2"); shift; shift;;
			    *)	gitCommand+=("$1"); shift; break;;
			esac
		    done
esac

exec git-wrapper "${gitCommand[@]}" "$@" -- "${stfiles[@]}"
