#!/bin/bash

printUsage()
{
    cat <<HELPTEXT
Delete <branch> from the local repository as well as origin.
HELPTEXT
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-f|--force] [--ignore-missing-in-origin] <branch> [...]'
}

branchDeleteOption=-d
isIgnoreMissingInOrigin=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	-f|--force)	shift; branchDeleteOption=-D;;
	--ignore-missing-in-origin)	shift; isIgnoreMissingInOrigin=t;;
	*)		break;;
    esac
done
if [ $# -eq 0 ]; then
    echo >&2 'Need (at least one) <branch> to delete!'
    exit 2
fi


# Need to determine remote branch names before deleting the local branches.
if [ "$isIgnoreMissingInOrigin" ]; then
    typeset -a remoteBranches=($(git-remotebr origin "$@" 2>/dev/null))
else
    typeset -a remoteBranches=($(git-remotebr origin "$@"))
fi

# Note: Process all passed branches in one fell swoop; this avoid re-querying
# (on push) the remote repository credentials for each branch. When one branch
# is invalid, an error is returned, but following (valid) branches are still
# processed: just as we'd like.
status=0
git branch $branchDeleteOption "$@" || status=$?

# If not all branches have remotes in origin, this is a failure of this command;
# the branch(es) have already been printed to stderr by git-remotebr.
[ ! "$isIgnoreMissingInOrigin" -a ${#remoteBranches[@]} -lt $# ] && status=1

if [ ${#remoteBranches[@]} -gt 0 ]; then
    git push origin --delete "${remoteBranches[@]#origin/}" || status=$?
fi
exit $status
