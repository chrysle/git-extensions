#!/bin/bash

# Source:
#   https://stackoverflow.com/questions/30208928/can-git-pull-automatically-stash-and-pop-pending-changes
#   https://github.com/aanand/git-up

log=terminal; type -t rabbitvcs >/dev/null && log=graphical
case "$1" in
    --gui)	shift; log=graphical;;
    --terminal)	shift; log=terminal;;
    --none)	shift; log=;;
esac

logChanges()
{
    case "$log" in
	'') ;;
	terminal)   git-onelinelog '' "$1";;
	graphical)  git-glog "$1" 2>&1;;
	*)	    printf >&2 'ASSERT: Invalid log: %q\n' "$log"; exit 3;;
    esac
}
remote="${1:?}"; shift
path=; [ $# -gt 0 ] && path="${remote}/${!#}" || path=$(git-remotebr "$remote" 2>/dev/null)
originalRevision=$(git rev-parse "$path" 2>/dev/null)

if [ "$GIT_UP_FETCH" ]; then
    git fetch "$remote" || exit $?
fi

# Here, merges typically happen from the master / base branch to pick up
# changes. If we need to rebase a (feature) branch during pulling, that means
# that there was (accidentally?) concurrent development. Here, we still like to
# keep the merges intact; the decision to flatten them or not should only come
# when reintegrating the branch (namely, whether to rebase or merge).
if [ "$GIT_UP_REBASE" ]; then
    git -c rebase.autoStash=true rebase --preserve-merges "${@:1:$(($#-1))}" "$path" || exit $?
else

    # Git 2.6 and later.
    git -c rebase.autoStash=true pull --rebase=preserve "$remote" "$@" || exit $?
    # Git 2.9 and later.
    #git pull --rebase=preserve --autostash "$remote" "$@" || exit $?
fi

if [ ! "$path" ]; then
    [ "$log" ] && echo >&2 "Warning: Could not determine updated path, no logging possible."
elif [ "$(git rev-parse "$path" 2>/dev/null)" = "$originalRevision" ]; then
    printf 'No changes in %s.\n' "$path"
else
    logChanges "@{1}..${path}"
fi
