	; Minimal supported Git version is 1.7; some stuff won't work with Git 1.6!

	; data transport commands overview:
	;     ----- add ----> -- commit --> -- publish -->
	;     ----- addu ---> -- commit --> -- push ----->
	; [WORKING COPY]  [INDEX]    [LOCAL REPO]  [REMOTE REPO]
	;     <------------ pull or rebase ---------------
	;                                   <-- fetch ----
	;     <--------- checkout HEAD ----
	;     <-- checkout --
	;                              ^-uncommit-/
	;                     <-- unstage -
	;     <---------------^---- wipe --
	;
	;     <--------- dh ---------------
	;     <---- d ------- <--- di -----

[alias]
	; Note: You cannot override a built-in Git command via an alias. Cp.
	; http://stackoverflow.com/questions/3538774/is-it-possible-to-override-git-command-by-git-alias
	;
	;alias = config --global --get-regexp 'alias\\..*' ; List all defined aliases.
	; Note: If you name the shell command "git-aliasname", there's no need
	; to define an alias here; Git will automatically pick it up. The
	; downside is that you cannot pass alias arguments to it here:
	; "!git-aliasname arg1" will NOT pass arg1 to the script!
	; (But "git aliasname arg1" on the command-line with work.)
	;alias = !git-alias
	; Note: You also cannot use a shell command "git-builtin" to override
	; the "git builtin" command! To achieve that, you need a custom "git"
	; shell function that intercepts the git call.
	; To do something with individual arguments, use something like this:
	;x = "!sh -c 'echo args: \"$@\"' -"

	;;confighelp: Browse this .gitconfig.
	configlist = config --local --list
	configedit = config --local --edit

	;;system-setup: Setup system-specific git configuration for a system.

	cherrypick = cherry-pick --no-commit	; Apply the changes introduced by some existing commits (cummulatively) to the index and working copy.
	cherrycommit = cherry-pick ; Apply and immediately commit each change (individually) introduced by some existing commit(s).
	;; add: Add and show status; --all/-A stages all, . stages new and modified, without deleted, -u stages modified and deleted, without new.
	;; addu: Stage modified and deleted, without new files, and show status.
	addhunk = add --patch	; Interactively cherry-pick and add individual hunks changed in the working copy to the index.
	addedit = add --edit	; Interactively choose lines to stage by directly editing the diff.
	;; addr: Add from root (i.e. all in working copy, not just everything inside CWD); defaults to modified and deleted, without new.
	;; adduntracked: Add only new files, respecting the ignore patterns.
	c = commit
	ca = commita
	;; commita: Commit all new files.
	cu = commit --all	; Commit all modified and deleted files, without new.
	commitu = commit --all	; Commit all modified and deleted files, without new.
	amen = commit --amend --reuse-message=HEAD	; Amend to last commit without re-editing the message.
	amenu = commit --all --amend --reuse-message=HEAD	; Amend all modified and deleted files to last commit without re-editing the message.
	amend = commit --amend --reedit-message=HEAD	; Amend to last commit.
	amendu = commit --all --amend --reedit-message=HEAD	; Amend all modified and deleted files to last commit.
	br = branch
	;;bra: List (local; -r remote-tracking; -a both) branches (optionally filtered by <glob>) ordered by date of most recent commit.
	deletebr = branch -d	; Delete branch; use odelete to remove the branch in origin, too.
	renamebr = branch -m	; Rename branch.
	;;archive: Tag <branch>, then delete it from the local repository as well as origin. Use to remove old branches that have been incorporated into master, or pass -f to force archiving.
	co = checkout
	com = checkout master
	cohunk = checkout --patch --	; Interactively cherry-pick and check out individual hunks from the index to the working copy.
	bl = !git-shortblame
	file-blame = !git ls-files | xargs -n1 -i{} git log -1 --pretty=format:\"%h %an (%ar) {}\" -- {} ; Show author name and last date for each file.
	st = status -sb ; Concise status with branch and tracking info.
	;;browse: Open origin / the passed pattern matching a remote in a browser.

	; Source: http://stackoverflow.com/questions/1360712/git-stash-cannot-apply-to-a-dirty-working-tree-please-stage-your-changes
	stash-pop-to-dirty = !git stash show -p | git apply && git stash drop	; When "stash pop" complains.

	n = notes show ; List annotations for HEAD / passed ref.
	ne = notes edit ; Edit / add annotations for existing commits. They don't change the history, and are local to a repo.

	; tags how-to:
	;	1. Add a new tag for the newest stable release: git tag -a v0.5 -m "Version 0.5 Stable"
	;	2. Push the latest tag to GitHub: git push --tags
	; Optional:
	;	3. Delete the v0.4 tag locally: git tag -d v0.4
	;	4. Delete the v0.4 tag on GitHub (which removes its download link): git push origin :v0.4

	root = rev-parse --show-toplevel	; Show root dir of this Git working copy.
	;; sh:  Enter a bunch of git commands interactively.
	serve = !git daemon --reuseaddr --verbose  --base-path=. --export-all ./.git ; Fire up a git daemon for the repo you are currently in.
	whois = "!sh -c 'git log -i -1 --pretty=\"format:%an <%ae>\n\" --author=\"$1\"' -" ; Look up person by name or email address.
	whodid = shortlog -n	; Show log grouped by name and sorted by the number of their commits.
	;; whodid -s: Show author names sorted by the number of their commits.
	statistics = shortlog -n -s	; Display a list of committers sorted by the frequency of commits. Use HEAD~42.. or v2.6..v2.7 to limit to range.
	whatis = show -s --pretty='tformat:%h (%s, %ad)' --date=short	; Print info about hash or commit name.

	d = diff    ; ... unstaged changes in working copy.
	dw = diff --color-words	; use word-based (not line-based) diff granularity
	dh = diff HEAD ; ... both staged or unstaged changes since last commit.
	di = diff --cached ; ... staged changes in the index about to be committed.
	diw = diff --cached --color-words	; staged changes, use word-based (not line-based) diff granularity
	;; dp:  ... with predecessor, either current HEAD or passed revision.
	dt = !git-difftoday ; Show all changes from today (override with --since=...) in a single big diff.

	g = grep --color -n
	gf = grep --files-with-matches
	; XXX: Apparently, aliases aren't case-sensitive.
	;; gF: grep --files-without-match
	g-f = grep --files-without-match

	;; ls: List all files under source control.
	;; ll: List hash, author, and date of the last commit for each file under source control.
	;; log et al: Consider only commit messages including /regexp/ via --grep=regexp.
	findchange = !git-pickaxe --date=relative -p ; Pickaxe: Show log and commits where text or /regexp/ was changed.
	findlogs = !git-pickaxe ; Pickaxe: Show log where text or /regexp/ was changed.
	findlg = !git-pickaxe --abbrev-commit --date=relative --decorate --pretty=oneline ; Pickaxe: Show short log where text or /regexp/ was changed.
	lc = whatchanged -p ; Logs together with diff between commits.
	;; show: Log together with diff for a particular commit.
	;; show :/regexp: Show the last commit whose message matches regexp.
	;; showfiles: Show the files modified in passed commit or commit range.
	; Note: Git 1.6.0 only supports %Cred, %Cgreen, %Cblue; only newer Git versions also support %C(more-colors).
	;; log: Use --name-status to include filenames like "svn log -v".
	l = log --abbrev-commit --date=relative --decorate --graph --pretty=oneline	; Minimal topology, tags and commit summary.
	lg = log --abbrev-commit --date=relative --decorate --graph --pretty=tformat:'%C(cyan)%h%Creset %Cgreen(%aN, %ar)%Creset %C(red bold)%d%Creset %s'	; One-line topology, author, date, tags and commit summary.
	lm = "!sh -c 'git log --author=\"$(git config --get user.name)\" --abbrev-commit --date=relative --decorate --graph --pretty=tformat:\"%C(cyan)%h%Creset %Cgreen(%cr)%Creset %C(red bold)%d%Creset %s\" \"$@\"' -"	; Like "git lg" filtered for my personal commits.
	logmine = "!sh -c 'git log --decorate --author=\"$(git config --get user.name)\" \"$@\"' -"	; "git log" filtered for my personal commits.
	lt = !git-logtoday ; Show log of today's (override with --since=...) changes formatted for including in pull request or email.
	logfetched = log ORIG_HEAD.. --stat --no-merges	; List all new commits after you fetched.
	last  = cat-file commit HEAD	; Show last commit info: Hashes and author. Use "git show" for more details.
	changes = diff --name-status -r ; Subversion-like 'svn status' reporting.
	;; describe: Show the most recent tag that is reachable from a commit.
	contains = "!sh -c 'git describe --contains \"$@\" || git name-rev --name-only \"$@\"' -"	; Show in which tag(s) a commit is contained, i.e. in which versions this was shipped, or, if that fails, from which branch it can be reached.
	picks = cherrypicks -v --abbrev=7	; See which changes from the current branch (e.g. feature) are already present in the passed branch (e.g. master).
	conflicts = "!sh -c 'git ls-files --unmerged \"$@\" | cut -f2 | uniq' -"    ; List files with merge conficts.
	; Source: http://akahn.net/2011/10/12/working-through-git-conflicts-in-vim.html

	cleanall = clean -d -x	; Remove all untracked files and directories, restoring a pristine working copy.
	;; lsprivate: Show all non-ignored files not under version control.
	;lsprivate = clean --dry-run ; Show all non-ignored files not under version control.
	;; rmprivate: Remove all non-ignored files not under version control.

	unstage = reset HEAD --	; Undo "git add <file>"; removes the file from the index, so that it isn't committed. (Alternatively, you can commit a few files via "git commit <file>" directly, bypassing the index.)
	unstagehunk = reset --patch HEAD --	; Interactively cherry-pick and remove individual hunks from the index.
	uncommit = reset --soft HEAD^ ; Cancel the last commit; keep working copy and index.
	wipe = reset --hard ; Reset HEAD, working copy and index.
	;; hardreset: Reset HEAD, working copy and index to <branch>. Ensures that the current branch isn't dirty.
	;; reset-to-tracked: Reset my current branch to the HEAD of the tracked branch. Use this when the local branch has been pointed elsewhere (e.g. due to an attempted rebase), and you want to restore the original state. The working copy is left intact.
	;; tracks: Show which remote branch is tracked by the current branch.
	rb = rebase
	rbi = rebase -i
	rbc = rebase --continue
	;; git rebase HEAD <feature> && git rebase HEAD @{-2}: rebase <feature> to current branch and merge back to current
	;; git merge --squash: Create a single commit on top of the current branch whose effect is the same as merging the other branch. Shorter form of interactive rebasing where you choose squash for all following commits.
	; merging
	;; checkout --ours:   will keep the original one we had (ORIG_HEAD) in case of merge conflict
	;; checkout --theirs: will keep the version merged in (MERGE_HEAD) in case of merge conflict
	;; mergeto: Merge the current branch to <target-branch>.
	mergem = mergeto master
	mt = mergetool
	;; merge-base: Identify branch point (common ancestor).

	;; remote show <repo>: Remote repository info, including tracked remote branches.
	obrowse = browse origin
	obr = "!sh -c 'git branch -r \"$@\"' | GREP_OPTIONS= grep origin/ -" ; List all branches in my GitHub clone.
	odiff = diff origin/master ; Show differences to my GitHub clone.
	olog = log --decorate origin/master ; Log of my GitHub clone.
	ofetch = fetch origin ; Get changes done to my GitHub clone through another Git repository, e.g. from another system. Use this, followed by git ohardreset, when origin has been reset (e.g. to an updated upstream).
	opull = pull origin ; Get and merge changes done to my GitHub clone through another Git repository, e.g. from another system.
	opush = push origin ; Re-publish of current / passed <branch> to the tracking GitHub clone to get them pulled into upstream.
	opublish = "!sh -c 'git push --set-upstream origin \"${1:-HEAD}\"' -"	; Initial publish of current / passed <branch> to my GitHub clone to get them pulled into upstream.
						; ... and set upstream tracking reference so that future pushes can omit the branch name (when push.default=tracking).
	; Instead, I could probably also setup automatic tracking, but:
	; - would lose the warning when trying to opush a branch that I haven't
	;   published yet.
	; - would default to pushing to foreign branches from someone (which I'm
	;   not allowed), instead of being forced to publish to my own GitHub
	;   clone.
	;
	;   git config branch.autosetupmerge true
	; tells git-branch and git-checkout to setup new branches so that git-pull(1)
	; will appropriately merge from that remote branch.  Recommended.  Without this,
	; you will have to add --track to your branch command or manually merge remote
	; tracking branches with "fetch" and then "merge".
	odelete = push origin --delete ; Delete remote <branch> in my GitHub clone. Older git must use "push origin :BRANCHNAME"
	oreset = reset-to-tracked --must-be-origin	; Reset my current branch (and working tree with --hard) to the HEAD of tracked branch of origin. Use this when the local branch has been pointed elsewhere (e.g. due to an attempted rebase), and you want to restore the original state. The working copy is left intact.
	;; ohardreset: Reset my current branch to the HEAD of the master / passed branch of origin. Use this after an ureset done in another repository. Ensures that the current branch isn't dirty.

	; How to add the upstream repository to my own repository:
  	;	git remote add upstream http://repo.or.cz/r/vcscommand.vim.git
	; Note: HTTPS is the default, but I've seen failures behind the corporate
	; firewall. On there other hand, I got a 403 when using HTTP.
	ubrowse = browse upstream
	upicks = cherrypicks -v --abbrev=7 upstream/master ; See which changes from the current branch are already present upstream.
	uco = checkout upstream/master ; Use with -b <newbranch> to start a patch based on the current upstream.
	udiff = diff upstream/master ; Show differences to upstream.
	ulog = log --decorate upstream/master ; Log of upstream.
	ufetch = fetch upstream	; Get upstream changes.
	umerge = merge upstream/master	; Merge upstream changes with my local repo.
	urb = rebase upstream/master	; Rebase my commits on top of the latest upstream. "co mybranch" first, clone it via "co -b myclone mybranch" if you want to keep the old one, or just use "urb mybranch".
	; To make pull default to rebase instead of merge, can use these:
	; # make "git pull" on master always use rebase
	; $ git config branch.master.rebase true
	; You can also set up a global option to set the last property for every
	; new tracked branch:
	; # setup rebase for every tracking branch
	; $ git config --global branch.autosetuprebase always
	; Source: http://mislav.uniqpath.com/2010/07/git-tips/

	uadd = remote add -f upstream	; Add upstream repository and fetch it.
	radd = remote add -f	; Add remote repository and fetch it.
	; other foreign repositories
	; To import someone's repository and work on it, do this:
	;   # Import.
	;   git remote add -f <someone> https://github.com/<someone>/<project>.git
	;   # The -f already did: git fetch <someone>
	;   # What has changed in his branch?
	;   git diff upstream/master..<someone>/<branch>
	;   git co -b <branch> <someone>/<branch>
	;   # Do changes ...
	;   # Publish to your GitHub clone to make the changes accessible to someone.
	;   git opublish <branch>
	ureset = "!sh -c 'git reset \"upstream/${1:-master}\" && git push -f origin' -"	; Reset my current branch to the HEAD of the master / passed branch of upstream, and push this to my GitHub clone. Use this after my pull requests have been accepted into upstream (but cherry-picked, in a different order, or intermingled with other requests, so that the commit history deviates from mine). The working copy is left intact, so you can effectively rebase any outstanding differences with a follow-up commit.
	;; uhardreset: Reset my current branch to the HEAD of the master / passed branch of upstream, and push this to my GitHub clone. Use this after my pull requests have been accepted into upstream (but cherry-picked, in a different order, or intermingled with other requests, so that the commit history deviates from mine). Ensures that the current branch isn't dirty.

	; How to fork a non-GitHub repository:
	; 1. git clone --origin=upstream http://repo.or.cz/r/vcscommand.vim.git
	; 2. On GitHub, create a new repository.
	; 3. cd vcscommand.git
  	; 4. git remote add origin git@github.com:inkarkat/vcscommand.vim.git
  	; 5. git push -u origin master

[clean]
	requireForce = false
[color]
	branch = auto
	diff = auto
	grep = auto
	interactive = auto
	status = auto
	ui = auto ; Requires git 1.6.
[color "branch"]
	current = normal reverse
	local = normal
	remote = normal dim
	plain = normal ul
[color "decorate"]
	branch = red reverse
	remoteBranch = red dim
	tag = red bold
	tags = red bold
	stash = red
	HEAD = red reverse
[color "diff"]
	plain = normal
	meta = cyan
	frag = blue bold
	old = red
	new = green
	commit = cyan
	; whitespace =
[color "grep"]
	external = --color=always
[color "interactive"]
	prompt = normal reverse
	header = normal bold
	help = normal
	; error =
[color "status"]
	header = green
	updated = normal
	changed = normal ul
	untracked = normal bold
[core]
	; No need to duplicate the setting here, as Git automatically falls back to
	; $EDITOR. (And I had Git 1.7.5 use an outdated /usr/bin/vim over
	; /usr/local/bin/vim.)
	;editor = vim

	; Do not highlight trailing whitespace; I use this in comments.
	whitespace=space-before-tab

	; Global user-specific ignored file list.
	excludesfile = ~/.gitignore

	; Convert newlines to the system's standard when checking out files, and
	; to LF newlines when committing.
	;autocrlf = true

	; Stop recording the executable file mode.
	; This can be necessary when using both MSysGit and Cygwin's Git, and
	; "git diff" shows this output for every file:
	;   old mode 100755
	;   new mode 100644
	; Best set this locally only via
	;   git config core.filemode false
	;filemode = false

	; When you cannot connect to git:// URLs from inside a company, use
	; socat to proxy Git through an HTTP CONNECT firewall.
	;   $ git fetch upstream
	;   github.com[0: 207.97.227.239]: errno=Connection timed out
	;   fatal: unable to connect a socket (Connection timed out)
	; Cp. ~/bin/gitproxy
	; Instead of enabling this here globally, try
	;   env GIT_PROXY_COMMAND=gitproxy git fetch upstream
	; or persist locally via
	;   git config core.gitproxy 'gitproxy'
	;gitproxy = gitproxy
[diff]
	renames = true
[log]
	; Even with "date=local", Git does not obey my locale's date settings.
	; Fortunately, "ISO" matches my preferred format pretty well, so I get dates
	; like "2012-03-16 10:19:21 +0100" instead of "Fri Mar 16 10:19:21 2012
	; +0100".
	date = iso
[merge]
	; Include the merge base = last common ancestor in the middle of a
	; change, after a |||||| marker.
	conflictstyle = diff3	; Requires git 1.6.
	; Note: Cannot use the full path here, as git only recognizes certain
	; executable names, or a custom mergetool.<tool>.cmd would need to be
	; implemented.
	tool = gvimdiff
[user]
	name = Ingo Karkat
	email = swdev@ingo-karkat.de
[github]
	user = inkarkat
[http]
	; Avoid SSL certificate errors when using https:// URLs due to the fact
	; that the up-to-date browser certificates may not be available to Git.
	; Try this first to verify that this is the problem:
	; env GIT_SSL_NO_VERIFY=true git clone https://github...
	;sslVerify = false
[interactive]
	; No need to acknowledge choices with <Enter> when adding hunks and for
	; other interactive commands.
	singlekey = true
[push]
	; git push will by default push all branches that have the same name on
	; the remote. Limit this behavior to just the current branch to prevent
	; accidental pushes to branches which you're not ready to push yet.
	; Source: http://mislav.uniqpath.com/2010/07/git-tips/
	default = tracking
	; "Tracking" is essentially a link between a local and remote branch.
	; When working on a local branch that tracks some other branch, you can
	; git pull and git push without any extra arguments and git will know
	; what to do.
[rebase]
	; When the commit log message begins with "squash! ..." or "fixup! ...",
	; and there is a commit whose title begins with the same ..., automatically
	; modify the todo list of rebase -i so that the commit marked for squashing
	; comes right after the commit to be modified, and change the action of the
	; moved commit from pick to squash (or fixup).
	; You can create those commits via
	; 	git commit --fixup|--squash <commit>
	; or even by referencing the most recent commit whose message contains <text>
	; 	git commit --squash :/<text>
	autosquash = true
