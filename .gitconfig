; Minimal supported Git version: 1.7; some stuff won't work with Git 1.6! 
[alias]
	; Note: You cannot override a built-in Git command via an alias. Cp.
	; http://stackoverflow.com/questions/3538774/is-it-possible-to-override-git-command-by-git-alias
	;
	;alias = config --global --get-regexp 'alias\\..*' ; List all defined aliases. 
	; Note: If you name the shell command "git-aliasname", there's no need
	; to define an alias here; Git will automatically pick it up. The
	; downside is that you cannot pass alias arguments to it here: 
	; "!git-aliasname arg1" will NOT pass arg1 to the script! 
	; (But "git aliasname arg1" on the command-line with work.) 
	;alias = !git-alias
	; Note: You also cannot use a shell command "git-builtin" to override
	; the "git builtin" command! To achieve that, you need a custom "git"
	; shell function that intercepts the git call. 
	; To do something with individual arguments, use something like this: 
	;x = "!sh -c 'echo args: \"$@\"' -"
	listconfig = config --global --list
	addhunk = add --patch	; Interactively cherry-pick add individual hunks changed in the working copy. 
	amend = commit --amend --reedit-message=HEAD	; Amend to last commit. 
	br = branch
	renamebr = branch -m	; Rename branch. 
	ci = commit -a ; Check in all changes. 
	cm = checkout master
	co = checkout
	bl = !git-shortblame
	file-blame = !git ls-files | xargs -n1 -i{} git log -1 --pretty=format:\"%h %an (%ar) {}\" -- {} ; Show author name and last date for each file. 
	st = status -sb ; Concise status with branch and tracking info. 

	n = notes show ; List annotations for HEAD / passed ref. 
	ne = notes edit ; Edit / add annotations for existing commits. They don't change the history, and are local to a repo. 

	; tags how-to: 
	;	1. Add a new tag for the newest stable release: git tag -a v0.5 -m "Version 0.5 Stable"
	;	2. Push the latest tag to GitHub: git push --tags
	; Optional: 
	;	3. Delete the v0.4 tag locally: git tag -d v0.4
	;	4. Delete the v0.4 tag on GitHub (which removes its download link): git push origin :v0.4

	root = !eval cd "$(pwd)/$(git rev-parse --show-cdup)" && pwd ; Show root dir of this Git working copy. 
	;; sh:  Enter a bunch of git commands interactively. 
	serve = !git daemon --reuseaddr --verbose  --base-path=. --export-all ./.git ; Fire up a git daemon for the repo you are currently in. 
	whois = "!sh -c 'git log -i -1 --pretty=\"format:%an <%ae>\n\" --author=\"$1\"' -" ; Look up person by name or email address. 
	whodid = shortlog -n	; Show log grouped by name and sorted by the number of their commits. 
	;; whodid -s: Show author names sorted by the number of their commits. 
	statistics = shortlog -n -s	; Display a list of committers sorted by the frequency of commits. Use HEAD~42.. or v2.6..v2.7 to limit to range. 
	whatis = show -s --pretty='tformat:%h (%s, %ad)' --date=short	; Print info about hash or commit name. 

	;; diff: --color-words to use word-based (not line-based) diff granularity
	d = diff    ; ... unstaged changes in working copy. 
	dh = diff HEAD ; ... both staged or unstaged changes since last commit. 
	di = diff --cached ; ... staged changes in the index about to be committed. 
	;; dp:  ... with predecessor, either current HEAD or passed revision. 
	dt = !git-difftoday ; Show all changes from today (override with --since=...) in a single big diff. 

	g = grep --color -n
	gf = grep --files-with-matches
	; XXX: Apparently, aliases aren't case-sensitive. 
	;; gF: grep --files-without-match
	g-f = grep --files-without-match
	
	;; log et al: Consider only commit messages including /regexp/ via --grep=regexp. 
	findchange = !git-pickaxe --date=relative -p ; Pickaxe: Show log and commits where text or /regexp/ was changed. 
	findlogs = !git-pickaxe ; Pickaxe: Show log where text or /regexp/ was changed. 
	findlg = !git-pickaxe --abbrev-commit --date=relative --decorate --pretty=oneline ; Pickaxe: Show short log where text or /regexp/ was changed. 
	lc = whatchanged -p ; Logs together with diff between commits. 
	;; show: Log together with diff for a particular commit. 
	;; show :/regexp: Show the last commit whose message matches regexp. 
	;; showfiles: Show the files modified in passed commit or commit range. 
	; Note: Git 1.6.0 only supports %Cred, %Cgreen, %Cblue; only newer Git versions also support %C(more-colors). 
	;; log: Use --name-status to include filenames like "svn log -v". 
	l = log --abbrev-commit --date=relative --decorate --graph --pretty=oneline	; Minimal topology, tags and commit summary. 
	lg = log --abbrev-commit --date=relative --decorate --graph --pretty=tformat:'%C(cyan)%h%Creset %Cgreen(%aN, %cr)%Creset %C(red bold)%d%Creset %s'	; One-line topology, author, date, tags and commit summary. 
	lm = "!sh -c 'git log --author=\"$(git config --get user.name)\" --abbrev-commit --date=relative --decorate --graph --pretty=tformat:\"%C(cyan)%h%Creset %Cgreen(%cr)%Creset %C(red bold)%d%Creset %s\" \"$@\"' -"	; Like "git lg" filtered for my personal commits. 
	logmine = "!sh -c 'git log --decorate --author=\"$(git config --get user.name)\" \"$@\"' -"	; "git log" filtered for my personal commits. 
	lt = !git-logtoday ; Show log of today's (override with --since=...) changes formatted for including in pull request or email. 
	logfetched = log ORIG_HEAD.. --stat --no-merges	; List all new commits after you fetched. 
	last  = cat-file commit HEAD	; Show last commit info: Hashes and author. Use "git show" for more details. 
	changes = diff --name-status -r ; Subversion-like 'svn status' reporting.
	;; describe: Show the most recent tag that is reachable from a commit. 
	contains = "!sh -c 'git describe --contains \"$@\" || git name-rev --name-only \"$@\"' -"	; Show in which tag(s) a commit is contained, i.e. in which versions this was shipped, or, if that fails, from which branch it can be reached. 
	picks = cherrypicks -v --abbrev=7	; See which changes from the current branch (e.g. feature) are already present in the passed branch (e.g. master). 
	conflicts = "!sh -c 'git ls-files --unmerged \"$@\" | cut -f2 | uniq' -"    ; List files with merge conficts. 
	; Source: http://akahn.net/2011/10/12/working-through-git-conflicts-in-vim.html

	cleanall = clean -d -x	; Remove all untracked files and directories, restoring a pristine working copy. 
	;; lsprivate: Show all non-ignored files not under version control. 
	;lsprivate = clean --dry-run ; Show all non-ignored files not under version control. 
	;; rmprivate: Remove all non-ignored files not under version control. 

	unstage = reset HEAD --	; Undo "git add <file>"; removes the file from the index, so that it isn't committed. (Alternatively, you can commit a few files via "git commit <file>" directly, bypassing the index.) 
	cancel = reset --soft HEAD^ ; Cancel the last commit; keep working copy and index. 
	wipe = reset --hard ; Reset HEAD, working copy and index. 
	;; reset-to-tracked: Reset my current branch to the HEAD of the tracked branch. Use this when the local branch has been pointed elsewhere (e.g. due to an attempted rebase), and you want to restore the original state. The working copy is left intact. 
	;; tracks: Show which remote branch is tracked by the current branch. 
	rb = rebase
	rbc = rebase --continue
	;; git rebase HEAD <feature> && git rebase HEAD @{-2}: rebase <feature> to current branch and merge back to current
	; merging
	;; checkout --ours:   will keep the original one we had (ORIG_HEAD) in case of merge conflict
	;; checkout --theirs: will keep the version merged in (MERGE_HEAD) in case of merge conflict
	mt = mergetool
	;; merge-base: Identify branch point (common ancestor). 

	;; remote show <repo>: Remote repository info, including tracked remote branches. 
	obr = "!sh -c 'git branch -r \"$@\"' | GREP_OPTIONS= grep origin/ -" ; List all branches in my GitHub clone. 
	odiff = diff origin/master ; Show differences to my GitHub clone. 
	opull = pull origin ; Get and merge changes done to my GitHub clone through another Git repository, e.g. from another system. 
	opush = push origin ; Re-publish of current / passed <branch> to the tracking GitHub clone to get them pulled into upstream. 
	opublish = "!sh -c 'git push --set-upstream origin \"${1:-HEAD}\"' -"	; Initial publish of current / passed <branch> to my GitHub clone to get them pulled into upstream.
						; ... and set upstream tracking reference so that future pushes can omit the branch name (when push.default=tracking). 
	; Instead, I could probably also setup automatic tracking, but: 
	; - would lose the warning when trying to opush a branch that I haven't
	;   published yet. 
	; - would default to pushing to foreign branches from someone (which I'm
	;   not allowed), instead of being forced to publish to my own GitHub
	;   clone. 
	;
	;   git config branch.autosetupmerge true
	; tells git-branch and git-checkout to setup new branches so that git-pull(1)
	; will appropriately merge from that remote branch.  Recommended.  Without this,
	; you will have to add --track to your branch command or manually merge remote
	; tracking branches with "fetch" and then "merge".
	odelete = push origin --delete ; Delete remote <branch> in my GitHub clone. Older git must use "push origin :BRANCHNAME"
	oreset = resettotracked --must-be-origin	; Reset my current branch to the HEAD of tracked branch of origin. Use this when the local branch has been pointed elsewhere (e.g. due to an attempted rebase), and you want to restore the original state. The working copy is left intact. 

	; How to add the upstream repository to my own repository: 
  	;	git remote add upstream http://repo.or.cz/r/vcscommand.vim.git
	upicks = cherrypicks -v --abbrev=7 upstream/master ; See which changes from the current branch are already present upstream. 
	uco = checkout upstream/master ; Use with -b <newbranch> to start a patch based on the current upstream. 
	udiff = diff upstream/master ; Show differences to upstream. 
	ufetch = fetch upstream	; Get upstream changes. 
	umerge = merge upstream/master	; Merge upstream changes with my local repo. 
	urb = rebase upstream/master	; Rebase my commits on top of the latest upstream. 
	; To make pull default to rebase instead of merge, can use these: 
	; # make "git pull" on master always use rebase
	; $ git config branch.master.rebase true
	; You can also set up a global option to set the last property for every
	; new tracked branch:
	; # setup rebase for every tracking branch
	; $ git config --global branch.autosetuprebase always
	; Source: http://mislav.uniqpath.com/2010/07/git-tips/

	; other foreign repositories
	; To import someone's repository and work on it, do this: 
	;   # Import. 
	;   git remote add -f <someone> https://github.com/<someone>/<project>.git
	;   # The -f already did: git fetch <someone>
	;   # What has changed in his branch? 
	;   git diff upstream/master..<someone>/<branch>
	;   git co -b <branch> <someone>/<branch>
	;   # Do changes ...
	;   # Publish to your GitHub clone to make the changes accessible to someone. 
	;   git opublish <branch>
	ureset = "!sh -c 'git reset \"upstream/${1:-master}\" && git push -f origin' -"	; Reset my current branch to the HEAD of the master / passed branch of upstream, and push this to my GitHub clone. Use this after my pull requests have been accepted into upstream (but cherry-picked, in a different order, or intermingled with other requests, so that the commit history deviates from mine). The working copy is left intact, so you can effectively rebase any outstanding differences with a follow-up commit. 

	; How to fork a non-GitHub repository:
	; 1. git clone --origin=upstream http://repo.or.cz/r/vcscommand.vim.git
	; 2. On GitHub, create a new repository. 
	; 3. cd vcscommand.git
  	; 4. git remote add origin git@github.com:inkarkat/vcscommand.vim.git
  	; 5. git push -u origin master

[clean]
	requireForce = false
[color]
	branch = auto
	diff = auto
	grep = auto
	interactive = auto
	status = auto
	ui = auto ; Requires git 1.6. 
[color "branch"]
	current = normal reverse
	local = normal
	remote = normal dim
	plain = normal ul
[color "decorate"]
	branch = red reverse
	remoteBranch = red dim
	tag = red bold
	tags = red bold
	stash = red
	HEAD = red reverse
[color "diff"]
	plain = normal
	meta = cyan
	frag = blue bold
	old = red
	new = green
	commit = cyan
	; whitespace =
[color "grep"]
	external = --color=always
[color "interactive"]
	prompt = normal reverse
	header = normal bold
	help = normal
	; error = 
[color "status"]
	header = green
	updated = normal
	changed = normal ul
	untracked = normal bold
[core]
	; No need to duplicate the setting here, as Git automatically falls back to
	; $EDITOR. (And I had Git 1.7.5 use an outdated /usr/bin/vim over
	; /usr/local/bin/vim.) 
	;editor = vim

	; Do not highlight trailing whitespace; I use this in comments. 
	whitespace=space-before-tab

	; Global user-specific ignored file list. 
	excludesfile = ~/.gitignore

	; Convert newlines to the system's standard when checking out files, and
	; to LF newlines when committing. 
	;autocrlf = true

	; Stop recording the executable file mode. 
	; This can be necessary when using both MSysGit and Cygwin's Git, and
	; "git diff" shows this output for every file: 
	;   old mode 100755
	;   new mode 100644
	; Best set this locally only via
	;   git config core.filemode false
	;filemode = false

	; When you cannot connect to git:// URLs from inside a company, use
	; socat to proxy Git through an HTTP CONNECT firewall. 
	;   $ git fetch upstream
	;   github.com[0: 207.97.227.239]: errno=Connection timed out
	;   fatal: unable to connect a socket (Connection timed out)
	; Cp. ~/bin/gitproxy
	; Instead of enabling this here globally, try
	;   env GIT_PROXY_COMMAND=gitproxy git fetch upstream
	; or persist locally via
	;   git config core.gitproxy 'gitproxy'
	;gitproxy = gitproxy
[diff]
	renames = true
[merge]
	; Include the merge base = last common ancestor in the middle of a
	; change, after a |||||| marker. 
	conflictstyle = diff3	; Requires git 1.6. 
	; Note: Cannot use the full path here, as git only recognizes certain
	; executable names, or a custom mergetool.<tool>.cmd would need to be
	; implemented. 
	tool = gvimdiff
[user]
	name = Ingo Karkat
	email = swdev@ingo-karkat.de
[github]
	user = inkarkat
[http]
	; Avoid SSL certificate errors when using https:// URLs due to the fact
	; that the up-to-date browser certificates may not be available to Git. 
	; Try this first to verify that this is the problem: 
	; env GIT_SSL_NO_VERIFY=true git clone https://github... 
	;sslVerify = false
[push]
	; git push will by default push all branches that have the same name on
	; the remote. Limit this behavior to just the current branch to prevent
	; accidental pushes to branches which you're not ready to push yet.
	; Source: http://mislav.uniqpath.com/2010/07/git-tips/
	default = tracking
	; "Tracking" is essentially a link between a local and remote branch.
	; When working on a local branch that tracks some other branch, you can
	; git pull and git push without any extra arguments and git will know
	; what to do.
