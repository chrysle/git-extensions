[alias]
	; Alternative: Do this programmatically:
	; 	git config --global alias.foo 'commit -m "foobar"'

	; Note: You cannot override a built-in Git command via an alias. Cp.
	; http://stackoverflow.com/questions/3538774/is-it-possible-to-override-git-command-by-git-alias
	;
	;alias = config --global --get-regexp 'alias\\..*' ; List all defined aliases.
	; Note: If you name the shell command "git-aliasname", there's no need
	; to define an alias here; Git will automatically pick it up. The
	; downside is that you cannot pass alias arguments to it here:
	; "!git-aliasname arg1" will NOT pass arg1 to the script!
	; (But "git aliasname arg1" on the command-line will work.)
	;alias = !git-alias
	; Note: You also cannot use a shell command "git-builtin" to override
	; the "git builtin" command! To achieve that, you need a custom "git"
	; shell function that intercepts the git call.
	; To do something with individual arguments, use something like this:
	;x = "!sh -c 'echo args: \"$@\"' -"
	; But I prefer defining an external git-subcommand for this.

	;; confighelp: Browse this .gitconfig.
	configlist = config --local --list
	configedit = config --local --edit

	me = config --get user.name
	me-in-github = config --get github.user

	; Stop recording the executable file mode.
	; This can be necessary when using both MSysGit and Cygwin's Git, and
	; "git diff" shows this output for every file:
	;   old mode 100755
	;   new mode 100644
	; Best set this locally only via
	;   git config core.filemode false
	;filemode = false
	config-no-filemode = config core.filemode false

	;; system-setup: Setup system-specific git configuration for a system.

	;; cat: Retrieve the contents of <path> as it exists in revision <ref>.

	cp = cherry-pick --no-commit	; Apply the changes introduced by some existing commits (cummulatively) to the index and working copy.
	cherrypick = cherry-pick --no-commit	; Apply the changes introduced by some existing commits (cummulatively) to the index and working copy.
	cpc = cherry-pick --continue	; Commit (after adding resolved conflicts) and continue with any subsequent commits to be cherry-picked.
	cps = cherry-pick --quit	; Forget about the current (conflicted) operation in progress.
	cpq = cherry-pick --abort	; Cancel the operation and return to the pre-sequence state.
	cherrycommit = cherry-pick ; Apply and immediately commit each change (individually) introduced by some existing commit(s).
	;; cherrymerge: Apply and immediately commit each change (individually), recording the existing commit id(s) in the commit message, like the merge tracking in Subversion.

	;; unapply-index: Revert the changes in the index to the working copy.
	;; checkout-head: Revert changes [for FILE(s)] in the working copy to the latest commit, but keep any changes in the index. These can be put back into the working copy via checkout.
	coh = checkout-head
	;; checkoutprevious: Revert changes [for FILE(s)] in the working copy to the commit prior to passed <commit>. Like "git checkout <commit>^ [-- FILE ...]" but doesn't write to the index / cause the "detached HEAD" status when no FILEs are passed. This is meant to be for temporary investigation or verifying a test failure without the committed fix, so no dirty working copy is allowed.
	cop = checkoutprevious
	;;revert: Apply the reverted changes only to the index and working copy; the index does not have to match the HEAD commit, so you can revert multiple commits in a row.
	revertcommit = revert	; Apply the reverted changes and commit.
	;; add: Add and show status; --all/-A stages all, . stages new and modified, without deleted, -u stages modified and deleted, without new.
	;; addn: Add all modified and deleted files except those matching FILE(s) or the escaped GLOB(s). Like addu, but with inverted meaning of the file arguments.
	;; addu: Stage modified and deleted, without new files, and show status.
	addhunk = add --patch	; Interactively cherry-pick and add individual hunks changed in the working copy to the index.
	addedit = add --edit	; Interactively choose lines to stage by directly editing the diff.
	;; addi: Add unstaged changes from already staged files; update stage.
	;; addr: Add from root (i.e. all in working copy, not just everything inside CWD); defaults to modified and deleted, without new.
	;; adduntracked: Add only new files, respecting the ignore patterns.
	addun = adduntracked
	;; adduu: Stage modified and deleted, and add new files, respecting the ignore patterns. Combination of git addu && git adduntracked.
	;; addselected: Interactively select (from modified files or passed list of files) files (or directly pass N, M, ... selections) to stage by number.
	adds = addselected
	addselectedhunk = addselected --patch
	addselectededit = addselected --edit
	;; addselecteduntracked: Interactively select (from new files, respecting the ignore patterns, or passed list of files) files (or directly pass N, M, ... selections) to stage by number.
	commitselected = selected-command commit	; Interactively select (from modified files or passed list of files) files (or directly pass N, M, ... selections) to commit by number.
	cs = commitselected

	c = wrapper commit
	ca = commita
	;; commita: Commit all new files.
	cu = wrapper commit --all	; Commit all modified and deleted files, without new.
	commitu = wrapper commit --all	; Commit all modified and deleted files, without new.
	;; cuu: Commit modified and deleted, and add new files, respecting the ignore patterns. Combination of git adduu && git commit.
	;; fixup: Commit with the intent of squashing this with the passed <commit> (id or :/<pattern>) via interactive rebase later.
	;; rbfixup: Commit and squash with the passed <commit> (id or :/<pattern>) via interactive rebase.
	amen = commit --amend --reuse-message=HEAD	; Amend to last commit without re-editing the message.
	amenu = commit --all --amend --reuse-message=HEAD	; Amend all modified and deleted files to last commit without re-editing the message.
	amend = commit --amend --reedit-message=HEAD	; Amend to last commit.
	amendu = commit --all --amend --reedit-message=HEAD	; Amend all modified and deleted files to last commit.
	;; commitfor: Commit for another author whose "NAME <EMAIL@HOST>" combo is either passed or selected from all previous committers (via passed AUTHOR-PATTERN).
	;; commitidentical: Commit directly (without further edits) with the same commit message as <commit>.
	commitlike = commitidentical --edit ;; Commit with the same commit message as <commit> as the base for further editing.
	;; credit: Amend another author whose "NAME <EMAIL@HOST>" combo is either passed or selected from all previous committers (via passed AUTHOR-PATTERN).
	;; show-branch: Shows the branch anchestry (heads are prefixed with !, current with *), then after a --- separator commits (+) and merges (-).
	;; br: branch with DWIM detection of branch listing via pattern (from the help: git branch <pattern> would try to create a branch, use git branch --list <pattern> to list matching branches).
	;; brname: Print current (local) branch name.
	;; bra: List (local; -r remote-tracking; -a both) branches (optionally filtered by <glob>) ordered by date of most recent commit.
	;; brc: List (local; -r remote-tracking; -a both) branches (optionally filtered by <glob>) ordered by date of first commit.
	;; createlocalbr: Create (and track) local branches for all remote branches (matching PATTERN).
	;; localbrdo: Check out all / the last committed N local branches (except for the current branch and master (and base branch if defined)) one by one and execute COMMAND (or drop back to the shell) for each).
	;; localbrcdo: Check out all / the last N local branches (except for the current branch and master (and base branch if defined)) ordered by date of first commit and execute COMMAND (or drop back to the shell) for each).
	;; prune: Remove old local branches that do not exist in <remote> any more.
	;; existsbr: Check whether the passed [remote/]branch exists.
	;; remotebr: Print corresponding remote/branch for the current branch (or return error).
	deletebr = branch -d	; Delete branch; use oldeletebr to remove the branch in origin, too (and odeletebr to just delete it in origin).
	renamebr = branch -m	; Rename branch.
	;; archivebr: Tag <branch>, then delete it from the local repository as well as origin. Use to remove old branches that have been incorporated into master, or pass -f to force archiving.
	;; archivelocalbr: Archive all / the first committed N local branches (except for the current branch and master (and base branch if defined)).
	;; archivelocalbrc: Archive all / the first committed N local branches (except for the current branch and master) ordered by date of first commit.
	archived = tag -l archive/*	; List all archived branches.
	; How to create an unrelated branch that doesn't hold the previous commit history (e.g. as for the gh-pages)
	; 1. git checkout --orphan gh-pages
	; 2. git rm -rf .
	co = checkout
	checkoutselected = selected-command checkout	; Interactively select (from modified files or passed list of files) files (or directly pass N, M, ... selections) to checkout by number.
	cos = checkoutselected
	;; cobr; Checkout passed <remote-branch>, tracking it if it doesn't yet exist locally, or ensuring that an existing tracked branch doesn't contradict the request.
	;; rco; Checkout passed <branch> in <remote>; fetching if needed and ensuring that an existing tracked branch doesn't contradict the request.
	;; rcolatest; Checkout local branch from latest (by sort order) passed <remote> [matching pattern].
	;; rcolatestc; Checkout local branch from the passed <remote> branch [matching pattern] that was created last (except the current branch and master (and base branch if defined)).
	colb = checkout @{-1}	; Checkout last checked-out branch.
	com = checkout master
	con = base-command checkout
	cohunk = checkout --patch --	; Interactively cherry-pick and check out individual hunks from the index to the working copy.
	bl = shortblame
	file-blame = !git ls-files | xargs -n1 -i{} git log -1 --pretty=format:\"%h %aN (%ar) {}\" -- {} ; Show author name and last date for each file.
	;; dirty: Test whether there are uncommitted changes, either in the working copy or the index.
	st = status -sb ; Concise status with branch and tracking info.
	;; sti; Concise status only for staged files inside the index.
	;; browse: Open origin / the passed pattern matching a remote in a browser.

	;; stash: Save a dirty working copy and index in a commit.
	;; stashi: Save only index in a commit; keep the dirty working copy.
	;; stashI: Synonym for stashw.
	stash-i = stash --keep-index
	stashw = stash --keep-index ; Save only dirty working copy; keep changes in index. Useful to compile / test partial commits by temporarily cleaning the working copy.
	stashuu = stash --include-untracked	; Save both modified and new (untracked files).
	stashhunk = stash --patch	; Interactively cherry-pick and stash away individual hunks changed in the working copy. Keeps changes in index unless --no-keep-index is given.
	;; stash list: Show all stashed commits.
	;; stash apply: Apply the topmost stashed commit onto the working copy.
	;; stash pop: Apply and the topmost stashed commit onto the working copy and remove it from the stash.
	;; stash drop: Remove a single stash.
	;; stash clear: Throw away all stashes.
	; Source: http://stackoverflow.com/questions/1360712/git-stash-cannot-apply-to-a-dirty-working-tree-please-stage-your-changes
	;; stash-pop-to-dirty: When "stash pop" complains.
	;; stash-to-branch: Stash the changes in a dirty working directory in a new branch.
	;; autostash: Automatically create a temporary stash before executing COMMAND, and apply it after the operation ends. This means that you can run Git commands that otherwise would complain on a dirty worktree.
	;; sync: Synchronize the local repository with the major remotes.

	n = notes show ; List annotations for HEAD / passed ref.
	ne = notes edit ; Edit / add annotations for existing commits. They don't change the history, and are local to a repo.
	; Source: http://git-scm.com/blog/2010/08/25/notes.html
	onotepush = push origin refs/notes/* ; notes are implemented as references, and must be pushed to share them.
	onotefetch = fetch origin refs/notes/*:refs/notes/* ; get notes from origin
	unotefetch = fetch upstream refs/notes/*:refs/notes/* ; get notes from upstream
	; To make the fetch automatic, add the following to .git/config:
	; [remote "origin"]
	; 	fetch = +refs/notes/*:refs/notes/*

	; tags how-to:
	;	1. Add a new tag for the newest stable release: git tag -a v0.5 -m "Version 0.5 Stable"
	;	2. Push the latest tag to GitHub: git push --tags
	; Optional:
	;	3. Delete the v0.4 tag locally: git tag -d v0.4
	;	4. Delete the v0.4 tag on GitHub (which removes its download link): git push origin :v0.4
	;; tag-version: Create an annotated tag, mostly used for official releases.

	root = rev-parse --show-toplevel	; Show root dir of this Git working copy.
	rel = rev-parse --show-prefix	; Show relative dir of the CWD in relation to the Git working copy root.
	; Note: Cannot define this as an external script; the property of being executed in the root dir would be lost.
	exec = "!sh -c 'exec \"$@\"' -"	; Execute a shell command in the root dir of this Git working copy; e.g. git exec make.
	; This works because shell aliases are always executed in the top-level directory.
	;; inside: Execute COMMAND (which probably contains Git command(s)) inside the working copy that FILE resides in. (Most Git commands only work from within the working copy.)
	;; wcdo: Execute "git SIMPLECOMMAND" and/or COMMANDLINE on each passed WORKING-COPY.
	;; wc-with-suffix-do: Like wcdo, but also work on clones or worktrees that sit next to the working copy.
	;; wcs-in-dir-do: Execute "git SIMPLECOMMAND" and/or COMMANDLINE on all repositories found in passed DIRSPECs.
	;; wcdo-command: Build a command that executes "git SIMPLECOMMAND" and/or COMMANDLINE on all repositories found in passed wrapper + what + baseDirs.
	;; sh:  Enter a bunch of git commands interactively.
	serve = !git daemon --reuseaddr --verbose  --base-path=. --export-all ./.git ; Fire up a git daemon for the repo you are currently in.
	;; worktree: Use parallel checkouts of <repository> in <path> (without having to push or pull!)
	; Source: /usr/share/doc/git-core/contrib/workdir/git-new-workdir
	export = archive
	;; export: git export -o latest.zip HEAD
	;; export: git export --format=tar --prefix=project-1.4.0/ v1.4.0 | gzip > project-1.4.0.tar.gz

	;; whois: Look up person by name or email address.
	whodid = shortlog -n	; Show log grouped by name and sorted by the number of their commits.
	;; whodid -s: Show author names sorted by the number of their commits.
	;; whoowns: Show statistics on how many lines were last committed by which author.
	;; whocontributed: Show author names sorted by the total size of the diffs they're responsible for.
	statistics = shortlog -n -s	; Display a list of committers sorted by the frequency of commits. Use HEAD~42.. or v2.6..v2.7 to limit to range.
	;; churn: Show sorted number of changes per file; arguments as to git log, e.g. --since="1 month ago" subdir
	whatis = show -s --pretty='tformat:%h (%s, %ad)' --date=short	; Print info about hash or commit name.

	d = diff    ; ... unstaged changes in working copy.
	;; diffc: context diff
	;; dl: Show separate diff of each file (instead of concatenating all changes), paged through with less.
	db = diff -w	; ignore all "blanks" whitespace changes
	dbl = dl -w
	dw = -c color.diff.old=red\\ reverse -c color.diff.new=green\\ reverse diff --color-words	; use word-based (not line-based) diff granularity
	dc = -c color.diff.old=red\\ reverse -c color.diff.new=green\\ reverse diff --color-words --word-diff-regex=.	; use character-based diff granularity
	dh = diff HEAD ; ... both staged or unstaged changes since last commit.
	dhl = dl HEAD
	di = diff --cached ; ... staged changes in the index about to be committed.
	dil = dl --cached
	diw = -c color.diff.old=red\\ reverse -c color.diff.new=green\\ reverse diff --cached --color-words	; staged changes, use word-based (not line-based) diff granularity
	dic = -c color.diff.old=red\\ reverse -c color.diff.new=green\\ reverse diff --cached --color-words	--word-diff-regex=.	; staged changes, use character-based diff granularity
	;; dp:  ... with predecessor, either current HEAD or passed revision.
	;; dpl:  ... with predecessor, either current HEAD or passed revision.
	;; diffuntil: ... over all commits until passed revision.
	;; diffselected: Interactively select (from modified files or passed list of files) files (or directly pass N, M, ... selections) to diff by number.
	ds = diffselected
	dis = diffselected --cached

	; Simple patch creation:
	;	$ git diff 1b6d > my.patch
	; On the receiving end, apply via:
	; 	$ git apply my.patch
	;; applycheck: Try to apply the passed patch and print statistics and result.
	;; applyrcheck: Try to apply the passed patch to the root and print statistics and result.
	;; applyr: Apply the patch from the root (as most patches should be based on the toplevel repository directory).
	;
	; Convert commit(s) to a (set of) patches [ <since> | <revision range> ],
	; ready to send by email, by default saved to CWD / -o outdir in mbox
	; format:
	; 	$ git format-patch --stdout 1b6d..HEAD^^
	; which can be passed to git send-email.
	ma = format-patch
	; On the receiving end, save an email to a file, then type:
	; 	$ git am < email.txt
	; Extract commits between revisions R1 and R2, and apply them on top of the current branch using git am to cherry-pick them:
	;   $ git ma -k --stdout R1..R2 | git am -3 -k
	; This applies the incoming patch and also creates a commit, including information such as the author.
	applymbox = am

	g = grep --color -n
	gf = grep --files-with-matches
	; XXX: Apparently, aliases aren't case-sensitive.
	;; gF: grep --files-without-match
	g-f = grep --files-without-match

	;; ls: List all files under source control.
	ll = ls --long --relative-date	; List hash, author, and date of the last commit for each file under source control.
	;; lll: List all files under source control with relative paths from the working copy's root.
	;; lllbrurl: List URLs to passed <remote> of all files under source control in the current branch. In contrast to lllhurl, this link will always point to the latest version on that branch.
	lllbrourl = lllbrurl origin
	lllbruurl = lllbrurl upstream
	;; lllhurl: List URLs to passed <remote> of all files under source control with the current / passed revision. In contrast to lllbrurl (which incorporates future changes done in the branch), this creates a permalink to the current file's contents.
	lllhourl = lllhurl origin
	lllhuurl = lllhurl upstream

	;; datediff: Show the time range of the commits done in the passed <revision-range>, or --since=<date>.

	;; ident-update: Update the expansion of $Id:$ via ident in the .gitattributes after a commit. Can --install a hook to do this automatically on each commit.
	; How to enable what strings:
	; 	1. echo '@(#) file $Id$ project' >> file
	; 	2. echo '* ident' >> .gitattributes
	;   3. git commit file .gitattributes
	;; find-blob: Find commit(s) (the last one is the earliest) which have the passed hash of a blob in their tree. Use to resolve the $Id$ put into a file via the "ident" gitattribute, e.g. in a what string.
	;; hash-object: Print the hash of the passed file (which must not have the $Id$ expanded!)
	; This is the same as
	;   (echo -e -n "blob $(stat -c %s "$file")\0"; cat "$file") | sha1sum

	;; log et al: Consider only commit messages including /regexp/ via --grep=regexp.
	;; log: Show commit logs, decorate with ref names, show in topological (instead of chronological) order, keeping merged branches together.
	log1 = log --max-count 1
	logtimeshifted = discrepancylog --field1 AuthorDate: --field2 CommitDate: --pretty=fuller ; Show logs of amended or rebased commits only.
	logonbehalf = discrepancylog --field1 Author: --field2 Commit: --pretty=fuller	; Show logs where author and committer are not the same person.
	; XXX: Git (2.7.4 on Ubuntu, 2.12 on Windows) somehow has a built-in alias of "pickaxe" to "blame". Because of this, we have to use the shell command syntax !git-pickaxe instead of simply pickaxe.
	findlogs = !git-pickaxe ; Pickaxe: Show log where text or /regexp/ was changed.
	findlogsv = !git-pickaxe log --name-status; Pickaxe: Show log and filenames where text or /regexp/ was changed.
	findlg = !git-pickaxe log --abbrev-commit --date=relative --decorate --pretty=oneline ; Pickaxe: Show short log where text or /regexp/ was changed.
	findchanges = !git-pickaxe log --date=relative -p ; Pickaxe: Show log and all commits where text or /regexp/ was changed.
	findshow = !git-pickaxe show ; Pickaxe: Show short log and commit of the most recent commit where text or /regexp/ was changed.
	lc = whatchanged -m -p ; Logs together with diff between commits.
	lcf = whatchanged -m --first-parent -p ; Logs together with diff between commits, but only from the "main branch" perspective, skipping commits that come from merged branches. This makes sense only when following a strict policy of merging all topic branches when staying on a single integration branch.
	;; lcl: Show separate log and diff of each commit (instead of concatenating all commits), paged through with less. Limit the number of commits via -<number> / -n <number> / --max-count <number> if the default of 20 isn't right.
	lclf = lcl --first-parent
	lcmine = mine-command lc ; Logs together with diff between commits, filtered for my personal commits.
	lcfmine = lcmine --first-parent
	;; show: Log together with diff for a particular commit; like lc but will not log further commits.
	showw = -c color.diff.old=red\\ reverse -c color.diff.new=green\\ reverse show --color-words	; use word-based (not line-based) diff granularity
	showc = -c color.diff.old=red\\ reverse -c color.diff.new=green\\ reverse show --color-words --word-diff-regex=.	; use character-based diff granularity
	showmine = mine-command show
	showwmine = mine-command -c color.diff.old=red\\ reverse -c color.diff.new=green\\ reverse show --color-words	; use word-based (not line-based) diff granularity
	showcmine = mine-command -c color.diff.old=red\\ reverse -c color.diff.new=green\\ reverse show --color-words --word-diff-regex=.	; use word-based (not line-based) diff granularity
	;; showfiles: Show the files modified in passed commit or commit range.
	; Commit logs Note: Git 1.6.0 only supports %Cred, %Cgreen, %Cblue for highlighting; only newer Git versions also support %C(more-colors).
	;; logv: Include filenames like "svn log -v". Still show all files of the commit even when filtering commits for certain paths; --name-status also filters the file list itself.
	logv1 = logv --max-count 1
	l = log --pretty=tformat:%s	; One-line list of commit summaries.
	l1 = l --max-count 1
	lo = log --pretty=format:%B	; Raw, unwrapped subject and body.
	lo1 = show --no-patch --pretty=format:%B	; Raw, unwrapped subject and body, only for the passed commits. Good for reusing for a new commit message.
	lmine = mine-command l ; git l, filtered for my personal commits.
	lmine1 = lmine --max-count 1
	lg = onelinelog '' --graph	; One-line topology, author, date, tags and commit summary.
	lg1 = lg --max-count 1
	;; lgv: One-line author, date, tags and commit summary, followed by modified filenames like "svn log -v".
	lh = log --pretty=tformat:%H	; One-line list of full commit hashes; useful with --grep.
	lh1 = lh --max-count 1
	lhmine = mine-command lh ; git lh, filtered for my personal commits.
	lhmine1 = lhmine --max-count 1
	;; lhurl: URLs to passed <remote> of all found commits.
	lhourl = lhurl origin	; My GitHub clone URLs of all found commits.
	lhourl1 = lhourl --max-count 1
	lhuurl = lhurl upstream	; Upstream URLs of all found commits.
	lhuurl1 = lhuurl --max-count 1
	lhourlv = lhurl origin --name-status	; My GitHub clone URLs and changed files of all found commits.
	lhourlv1 = lhourlv --max-count 1
	lhuurlv = lhurl upstream --name-status	; Upstream URLs and changed files of all found commits.
	lhuurlv1 = lhuurlv --max-count 1
	;; lghighlight: git lg, with lines that match passed PATTERN highlighted
	lghmine = mine-command --no-option-name lghighlight ; git lg, with my personal commits highlighted
	;; lgmine: git lg, filtered for my personal commits.
	lgmine1 = lgmine --max-count 1
	logmine = mine-command log ; git log, filtered for my personal commits.
	logmine1 = logmine --max-count 1
	logvmine = mine-command logv ; logmine including filenames
	logvmine1 = logvmine --max-count 1
	lminetoday = today-command mine-command l ; One-line list of commit summaries of my changes of today.
	lgminetoday = today-command mine-command lg ; One-line topology, author, date, tags and commit summary of my changes of today.
	logminetoday = today-command mine-command log ; Show log of my changes of today.
	logvminetoday = today-command mine-command log --name-status

	;; logi: Show commit logs of files in index.
	;; lci: Logs together with diff between commits. of files in index.
	;; lgi: One-line topology, author, date, tags and commit summary of files in index.

	;; rev-parse: Resolve commit id from various passed ref types.
	;; commitid: Resolve commit id from the passed commit ref, with error message (unless -n|--no-error). With -q|--quiet, just performs the check without any output.
	;; equals: Check whether all passed refs refer to the same commit.

	;; td...: Log variants that only cover changes committed today.
	tdd = today-command --no-range diffuntil ; Show all changes from today in a single big diff.
	tddl = today-command --no-range diffuntill ; Show all changes from today in a big diffs, separately for each changed file.
	tdma = today-command format-patch
	tdfindlogs = today-command findlogs
	tdfindlogsv = today-command findlogsv
	tdfindlg = today-command findlg
	tdfindchanges = today-command findchanges
	tdfindshow = today-command findshow
	tdlc = today-command lc
	tdlcf = today-command lcf
	tdlcl = today-command lcl
	tdlclf = today-command lclf
	tdlcmine = today-command lcmine
	tdlcfmine = today-command lcfmine
	tdshow = today-command show
	tdshowfiles = today-command showfiles
	tdlog = today-command log
	tdlogv = today-command logv
	tdglog = today-command glog
	tdl = today-command l
	tdlmine = today-command lmine
	tdlg = today-command lg
	tdlgv = today-command lgv
	tdlh = today-command lh --reverse
	tdlhmine = today-command lhmine --reverse
	tdlhurl = today-command lhurl
	tdlhourl = today-command lhourl --reverse
	tdlhuurl = today-command lhuurl --reverse
	tdlhourlv = today-command lhourlv --reverse
	tdlhuurlv = today-command lhuurlv --reverse
	tdlgmine = today-command lgmine
	tdlogmine = today-command logmine
	tdrbi = today-command --no-range rebase -i
	tdbase = today-command --no-range name-rev --name-only

	;; rev-range: Run a Git command with a revision range from the passed revision up to HEAD.
	;; rev-range-this-branch: Run a Git command with a revision range that covers the current branch (up to another reference).
	;; rev-range-incoming: Run a Git command with the revision range of the commits that already exist in remote on the current branch, but not yet in the local branch.
	;; rev-range-outgoing: Run a Git command with the revision range of the commits that already exist on the current branch, but not yet in the corresponding remote branch.

	;; br...: Log variants that only cover the current branch (as tagged in the history)
	brd = rev-range-this-branch diff
	brdl = rev-range-this-branch dl
	brma = rev-range-this-branch format-patch
	brfindlogs = rev-range-this-branch --keep-last findlogs
	brfindlogsv = rev-range-this-branch --keep-last findlogsv
	brfindlg = rev-range-this-branch --keep-last findlg
	brfindchanges = rev-range-this-branch --keep-last findchanges
	brfindshow = rev-range-this-branch --keep-last findshow
	brlc = rev-range-this-branch --one-more-command log lc
	brlcf = rev-range-this-branch --one-more-command log lcf
	brlcl = rev-range-this-branch lcl
	brlclf = rev-range-this-branch lclf
	brlcmine = rev-range-this-branch --one-more-command log lcmine
	brlcfmine = rev-range-this-branch --one-more-command log lcfmine
	brshow = rev-range-this-branch --one-more-command log show
	brshowfiles = rev-range-this-branch showfiles
	brlog = rev-range-this-branch --one-more log
	brlogv = rev-range-this-branch --one-more logv
	brglog = rev-range-this-branch glog
	brl = rev-range-this-branch l
	brlmine = rev-range-this-branch lmine
	brlg = rev-range-this-branch --one-more lg
	brlgn = rev-range-this-branch lg
	brlgv = rev-range-this-branch --one-more lgv
	brlh = rev-range-this-branch lh --reverse
	brlhmine = rev-range-this-branch lhmine --reverse
	brlhurl = rev-range-this-branch lhurl
	brlhourl = rev-range-this-branch lhourl --reverse
	brlhuurl = rev-range-this-branch lhuurl --reverse
	brlhourlv = rev-range-this-branch lhourlv --reverse
	brlhuurlv = rev-range-this-branch lhuurlv --reverse
	brlgmine = rev-range-this-branch --one-more lgmine
	brlogmine = rev-range-this-branch --one-more logmine
	brrbi = rev-range-this-branch --no-range --one-more-command ^ rebase -i
	brbase = rev-range-this-branch --no-range name-rev --name-only

	;; b2r...: Log variants that only cover the current and preceding branch (as tagged in the history)
	b2rd = rev-range-this-branch --branch-number 2 diff
	b2rdl = rev-range-this-branch --branch-number 2 dl
	b2mal = rev-range-this-branch --branch-number 2 format-patch
	b2rfindlogs = rev-range-this-branch --branch-number 2 --keep-last findlogs
	b2rfindlogsv = rev-range-this-branch --branch-number 2 --keep-last findlogsv
	b2rfindlg = rev-range-this-branch --branch-number 2 --keep-last findlg
	b2rfindchanges = rev-range-this-branch --branch-number 2 --keep-last findchanges
	b2rfindshow = rev-range-this-branch --branch-number 2 --keep-last findshow
	b2rlc = rev-range-this-branch --branch-number 2 --one-more-command log lc
	b2rlcf = rev-range-this-branch --branch-number 2 --one-more-command log lcf
	b2rlcl = rev-range-this-branch --branch-number 2 lcl
	b2rlclf = rev-range-this-branch --branch-number 2 lclf
	b2rlcmine = rev-range-this-branch --branch-number 2 --one-more-command log lcmine
	b2rlcfmine = rev-range-this-branch --branch-number 2 --one-more-command log lcfmine
	b2rshow = rev-range-this-branch --branch-number 2 --one-more-command log show
	b2rshowfiles = rev-range-this-branch --branch-number 2 showfiles
	b2rlog = rev-range-this-branch --branch-number 2 --one-more log
	b2rlogv = rev-range-this-branch --branch-number 2 --one-more logv
	b2rglog = rev-range-this-branch --branch-number 2 glog
	b2rl = rev-range-this-branch --branch-number 2 l
	b2rlmine = rev-range-this-branch --branch-number 2 lmine
	b2rlg = rev-range-this-branch --branch-number 2 --one-more lg
	b2rlgn = rev-range-this-branch --branch-number 2 lg
	b2rlgv = rev-range-this-branch --branch-number 2 --one-more lgv
	b2rlh = rev-range-this-branch --branch-number 2 lh --reverse
	b2rlhmine = rev-range-this-branch --branch-number 2 lhmine --reverse
	b2rlhurl = rev-range-this-branch --branch-number 2 lhurl
	b2rlhourl = rev-range-this-branch --branch-number 2 lhourl --reverse
	b2rlhuurl = rev-range-this-branch --branch-number 2 lhuurl --reverse
	b2rlhourlv = rev-range-this-branch --branch-number 2 lhourlv --reverse
	b2rlhuurlv = rev-range-this-branch --branch-number 2 lhuurlv --reverse
	b2rlgmine = rev-range-this-branch --branch-number 2 --one-more lgmine
	b2rlogmine = rev-range-this-branch --branch-number 2 --one-more logmine
	b2rrbi = rev-range-this-branch --branch-number 2 --no-range --one-more-command ^ rebase -i
	b2rbase = rev-range-this-branch --branch-number 2 --no-range name-rev --name-only

	;; b3r...: Log variants that only cover the current and two preceding branches (as tagged in the history)
	b3rd = rev-range-this-branch --branch-number 3 diff
	b3rdl = rev-range-this-branch --branch-number 3 dl
	b3mal = rev-range-this-branch --branch-number 3 format-patch
	b3rfindlogs = rev-range-this-branch --branch-number 3 --keep-last findlogs
	b3rfindlogsv = rev-range-this-branch --branch-number 3 --keep-last findlogsv
	b3rfindlg = rev-range-this-branch --branch-number 3 --keep-last findlg
	b3rfindchanges = rev-range-this-branch --branch-number 3 --keep-last findchanges
	b3rfindshow = rev-range-this-branch --branch-number 3 --keep-last findshow
	b3rlc = rev-range-this-branch --branch-number 3 --one-more-command log lc
	b3rlcf = rev-range-this-branch --branch-number 3 --one-more-command log lcf
	b3rlcl = rev-range-this-branch --branch-number 3 lcl
	b3rlclf = rev-range-this-branch --branch-number 3 lclf
	b3rlcmine = rev-range-this-branch --branch-number 3 --one-more-command log lcmine
	b3rlcfmine = rev-range-this-branch --branch-number 3 --one-more-command log lcfmine
	b3rshow = rev-range-this-branch --branch-number 3 --one-more-command log show
	b3rshowfiles = rev-range-this-branch --branch-number 3 showfiles
	b3rlog = rev-range-this-branch --branch-number 3 --one-more log
	b3rlogv = rev-range-this-branch --branch-number 3 --one-more logv
	b3rglog = rev-range-this-branch --branch-number 3 glog
	b3rl = rev-range-this-branch --branch-number 3 l
	b3rlmine = rev-range-this-branch --branch-number 3 lmine
	b3rlg = rev-range-this-branch --branch-number 3 --one-more lg
	b3rlgn = rev-range-this-branch --branch-number 3 lg
	b3rlgv = rev-range-this-branch --branch-number 3 --one-more lgv
	b3rlh = rev-range-this-branch --branch-number 3 lh --reverse
	b3rlhmine = rev-range-this-branch --branch-number 3 lhmine --reverse
	b3rlhurl = rev-range-this-branch --branch-number 3 lhurl
	b3rlhourl = rev-range-this-branch --branch-number 3 lhourl --reverse
	b3rlhuurl = rev-range-this-branch --branch-number 3 lhuurl --reverse
	b3rlhourlv = rev-range-this-branch --branch-number 3 lhourlv --reverse
	b3rlhuurlv = rev-range-this-branch --branch-number 3 lhuurlv --reverse
	b3rlgmine = rev-range-this-branch --branch-number 3 --one-more lgmine
	b3rlogmine = rev-range-this-branch --branch-number 3 --one-more logmine
	b3rrbi = rev-range-this-branch --branch-number 3 --no-range --one-more-command ^ rebase -i
	b3rbase = rev-range-this-branch --branch-number 3 --no-range name-rev --name-only

	;; bm...: Log variants that cover the differences of the current branch to master.
	bmd = rev-range --revision master --end-revision HEAD diff
	bmdl = rev-range --revision master --end-revision HEAD dl
	bmma = rev-range --revision master --end-revision HEAD format-patch
	bmfindlogs = rev-range --revision master --end-revision HEAD --keep-last findlogs
	bmfindlogsv = rev-range --revision master --end-revision HEAD --keep-last findlogsv
	bmfindlg = rev-range --revision master --end-revision HEAD --keep-last findlg
	bmfindchanges = rev-range --revision master --end-revision HEAD --keep-last findchanges
	bmfindshow = rev-range --revision master --end-revision HEAD --keep-last findshow
	bmlc = rev-range --revision master --end-revision HEAD --one-more-command log lc
	bmlcf = rev-range --revision master --end-revision HEAD --one-more-command log lcf
	bmlcl = rev-range --revision master --end-revision HEAD lcl
	bmlclf = rev-range --revision master --end-revision HEAD lclf
	bmlcmine = rev-range --revision master --end-revision HEAD --one-more-command log lcmine
	bmlcfmine = rev-range --revision master --end-revision HEAD --one-more-command log lcfmine
	bmshow = rev-range --revision master --end-revision HEAD --one-more-command log show
	bmshowfiles = rev-range --revision master --end-revision HEAD showfiles
	bmlog = rev-range --revision master --end-revision HEAD --one-more log
	bmlogv = rev-range --revision master --end-revision HEAD --one-more logv
	bmglog = rev-range --revision master --end-revision HEAD glog
	bml = rev-range --revision master --end-revision HEAD l
	bmlmine = rev-range --revision master --end-revision HEAD lmine
	bmlg = rev-range --revision master --end-revision HEAD --one-more lg
	bmlgn = rev-range --revision master --end-revision HEAD lg
	bmlgv = rev-range --revision master --end-revision HEAD --one-more lgv
	bmlh = rev-range --revision master --end-revision HEAD lh --reverse
	bmlhmine = rev-range --revision master --end-revision HEAD lhmine --reverse
	bmlhurl = rev-range --revision master --end-revision HEAD lhurl
	bmlhourl = rev-range --revision master --end-revision HEAD lhourl --reverse
	bmlhuurl = rev-range --revision master --end-revision HEAD lhuurl --reverse
	bmlhourlv = rev-range --revision master --end-revision HEAD lhourlv --reverse
	bmlhuurlv = rev-range --revision master --end-revision HEAD lhuurlv --reverse
	bmlgmine = rev-range --revision master --end-revision HEAD --one-more lgmine
	bmlogmine = rev-range --revision master --end-revision HEAD --one-more logmine
	bmrbi = rev-range --revision master --no-range --one-more-command ^ rebase -i
	; bmbase would always print "master".

	;; bn...: Log variants that cover the differences of the current branch to the base branch.
	bnd = base-command --keep-position rev-range --revision BASE --end-revision HEAD diff
	bndl = base-command --keep-position rev-range --revision BASE --end-revision HEAD dl
	bnma = base-command --keep-position rev-range --revision BASE --end-revision HEAD format-patch
	bnfindlogs = base-command --keep-position rev-range --revision BASE --end-revision HEAD --keep-last findlogs
	bnfindlogsv = base-command --keep-position rev-range --revision BASE --end-revision HEAD --keep-last findlogsv
	bnfindlg = base-command --keep-position rev-range --revision BASE --end-revision HEAD --keep-last findlg
	bnfindchanges = base-command --keep-position rev-range --revision BASE --end-revision HEAD --keep-last findchanges
	bnfindshow = base-command --keep-position rev-range --revision BASE --end-revision HEAD --keep-last findshow
	bnlc = base-command --keep-position rev-range --revision BASE --end-revision HEAD --one-more-command log lc
	bnlcf = base-command --keep-position rev-range --revision BASE --end-revision HEAD --one-more-command log lcf
	bnlcl = base-command --keep-position rev-range --revision BASE --end-revision HEAD lcl
	bnlclf = base-command --keep-position rev-range --revision BASE --end-revision HEAD lclf
	bnlcmine = base-command --keep-position rev-range --revision BASE --end-revision HEAD --one-more-command log lcmine
	bnlcfmine = base-command --keep-position rev-range --revision BASE --end-revision HEAD --one-more-command log lcfmine
	bnshow = base-command --keep-position rev-range --revision BASE --end-revision HEAD --one-more-command log show
	bnshowfiles = base-command --keep-position rev-range --revision BASE --end-revision HEAD showfiles
	bnlog = base-command --keep-position rev-range --revision BASE --end-revision HEAD --one-more log
	bnlogv = base-command --keep-position rev-range --revision BASE --end-revision HEAD --one-more logv
	bnglog = base-command --keep-position rev-range --revision BASE --end-revision HEAD glog
	bnl = base-command --keep-position rev-range --revision BASE --end-revision HEAD l
	bnlmine = base-command --keep-position rev-range --revision BASE --end-revision HEAD lmine
	bnlg = base-command --keep-position rev-range --revision BASE --end-revision HEAD --one-more lg
	bnlgn = base-command --keep-position rev-range --revision BASE --end-revision HEAD lg
	bnlgv = base-command --keep-position rev-range --revision BASE --end-revision HEAD --one-more lgv
	bnlh = base-command --keep-position rev-range --revision BASE --end-revision HEAD lh --reverse
	bnlhmine = base-command --keep-position rev-range --revision BASE --end-revision HEAD lhmine --reverse
	bnlhurl = base-command --keep-position rev-range --revision BASE --end-revision HEAD lhurl
	bnlhourl = base-command --keep-position rev-range --revision BASE --end-revision HEAD lhourl --reverse
	bnlhuurl = base-command --keep-position rev-range --revision BASE --end-revision HEAD lhuurl --reverse
	bnlhourlv = base-command --keep-position rev-range --revision BASE --end-revision HEAD lhourlv --reverse
	bnlhuurlv = base-command --keep-position rev-range --revision BASE --end-revision HEAD lhuurlv --reverse
	bnlgmine = base-command --keep-position rev-range --revision BASE --end-revision HEAD --one-more lgmine
	bnlogmine = base-command --keep-position rev-range --revision BASE --end-revision HEAD --one-more logmine
	bnrbi = base-command --keep-position rev-range --revision BASE --no-range --one-more-command ^ rebase -i
	bnbase = base-command --keep-position rev-range --revision BASE --no-range name-rev --name-only

	;; bl...: Log variants that cover the differences of the current branch to the previously checked out branch (typically the one it was branched off).
	bld = rev-range --revision @{-1} --end-revision HEAD diff
	bldl = rev-range --revision @{-1} --end-revision HEAD dl
	blma = rev-range --revision @{-1} --end-revision HEAD format-patch
	blfindlogs = rev-range --revision @{-1} --end-revision HEAD --keep-last findlogs
	blfindlogsv = rev-range --revision @{-1} --end-revision HEAD --keep-last findlogsv
	blfindlg = rev-range --revision @{-1} --end-revision HEAD --keep-last findlg
	blfindchanges = rev-range --revision @{-1} --end-revision HEAD --keep-last findchanges
	blfindshow = rev-range --revision @{-1} --end-revision HEAD --keep-last findshow
	bllc = rev-range --revision @{-1} --end-revision HEAD --one-more-command log lc
	bllcf = rev-range --revision @{-1} --end-revision HEAD --one-more-command log lcf
	bllcl = rev-range --revision @{-1} --end-revision HEAD lcl
	bllclf = rev-range --revision @{-1} --end-revision HEAD lclf
	bllcmine = rev-range --revision @{-1} --end-revision HEAD --one-more-command log lcmine
	bllcfmine = rev-range --revision @{-1} --end-revision HEAD --one-more-command log lcfmine
	blshow = rev-range --revision @{-1} --end-revision HEAD --one-more-command log show
	blshowfiles = rev-range --revision @{-1} --end-revision HEAD showfiles
	bllog = rev-range --revision @{-1} --end-revision HEAD --one-more log
	bllogv = rev-range --revision @{-1} --end-revision HEAD --one-more logv
	blglog = rev-range --revision @{-1} --end-revision HEAD glog
	bll = rev-range --revision @{-1} --end-revision HEAD l
	bllmine = rev-range --revision @{-1} --end-revision HEAD lmine
	bllg = rev-range --revision @{-1} --end-revision HEAD --one-more lg
	bllgn = rev-range --revision @{-1} --end-revision HEAD lg
	bllgv = rev-range --revision @{-1} --end-revision HEAD --one-more lgv
	bllh = rev-range --revision @{-1} --end-revision HEAD lh --reverse
	bllhmine = rev-range --revision @{-1} --end-revision HEAD lhmine --reverse
	bllhurl = rev-range --revision @{-1} --end-revision HEAD lhurl
	bllhourl = rev-range --revision @{-1} --end-revision HEAD lhourl --reverse
	bllhuurl = rev-range --revision @{-1} --end-revision HEAD lhuurl --reverse
	bllhourlv = rev-range --revision @{-1} --end-revision HEAD lhourlv --reverse
	bllhuurlv = rev-range --revision @{-1} --end-revision HEAD lhuurlv --reverse
	bllgmine = rev-range --revision @{-1} --end-revision HEAD --one-more lgmine
	bllogmine = rev-range --revision @{-1} --end-revision HEAD --one-more logmine
	blrbi = rev-range --revision @{-1} --no-range --one-more-command ^ rebase -i
	blbase = rev-range --revision @{-1} --no-range name-rev --name-only

	;; b2l...: Log variants that cover the differences of the current branch to the second-last checked out branch.
	b2ld = rev-range --revision @{-2} --end-revision HEAD diff
	b2ldl = rev-range --revision @{-2} --end-revision HEAD dl
	b2mal = rev-range --revision @{-2} --end-revision HEAD format-patch
	b2lfindlogs = rev-range --revision @{-2} --end-revision HEAD --keep-last findlogs
	b2lfindlogsv = rev-range --revision @{-2} --end-revision HEAD --keep-last findlogsv
	b2lfindlg = rev-range --revision @{-2} --end-revision HEAD --keep-last findlg
	b2lfindchanges = rev-range --revision @{-2} --end-revision HEAD --keep-last findchanges
	b2lfindshow = rev-range --revision @{-2} --end-revision HEAD --keep-last findshow
	b2llc = rev-range --revision @{-2} --end-revision HEAD --one-more-command log lc
	b2llcf = rev-range --revision @{-2} --end-revision HEAD --one-more-command log lcf
	b2llcl = rev-range --revision @{-2} --end-revision HEAD lcl
	b2llclf = rev-range --revision @{-2} --end-revision HEAD lclf
	b2llcmine = rev-range --revision @{-2} --end-revision HEAD --one-more-command log lcmine
	b2llcfmine = rev-range --revision @{-2} --end-revision HEAD --one-more-command log lcfmine
	b2lshow = rev-range --revision @{-2} --end-revision HEAD --one-more-command log show
	b2lshowfiles = rev-range --revision @{-2} --end-revision HEAD showfiles
	b2llog = rev-range --revision @{-2} --end-revision HEAD --one-more log
	b2llogv = rev-range --revision @{-2} --end-revision HEAD --one-more logv
	b2lglog = rev-range --revision @{-2} --end-revision HEAD glog
	b2ll = rev-range --revision @{-2} --end-revision HEAD l
	b2llmine = rev-range --revision @{-2} --end-revision HEAD lmine
	b2llg = rev-range --revision @{-2} --end-revision HEAD --one-more lg
	b2llgn = rev-range --revision @{-2} --end-revision HEAD lg
	b2llgv = rev-range --revision @{-2} --end-revision HEAD --one-more lgv
	b2llh = rev-range --revision @{-2} --end-revision HEAD lh --reverse
	b2llhmine = rev-range --revision @{-2} --end-revision HEAD lhmine --reverse
	b2llhurl = rev-range --revision @{-2} --end-revision HEAD lhurl
	b2llhourl = rev-range --revision @{-2} --end-revision HEAD lhourl --reverse
	b2llhuurl = rev-range --revision @{-2} --end-revision HEAD lhuurl --reverse
	b2llhourlv = rev-range --revision @{-2} --end-revision HEAD lhourlv --reverse
	b2llhuurlv = rev-range --revision @{-2} --end-revision HEAD lhuurlv --reverse
	b2llgmine = rev-range --revision @{-2} --end-revision HEAD --one-more lgmine
	b2llogmine = rev-range --revision @{-2} --end-revision HEAD --one-more logmine
	b2lrbi = rev-range --revision @{-2} --no-range --one-more-command ^ rebase -i
	b2lbase = rev-range --revision @{-2} --no-range name-rev --name-only

	;; bp...: Log variants that cover the differences of the current branch to where the tip of the branch was previously. Useful to see the changes that were just pulled.
	bpd = rev-range --revision @{1} --end-revision HEAD diff
	bpdl = rev-range --revision @{1} --end-revision HEAD dl
	bpma = rev-range --revision @{1} --end-revision HEAD format-patch
	bpfindlogs = rev-range --revision @{1} --end-revision HEAD --keep-last findlogs
	bpfindlogsv = rev-range --revision @{1} --end-revision HEAD --keep-last findlogsv
	bpfindlg = rev-range --revision @{1} --end-revision HEAD --keep-last findlg
	bpfindchanges = rev-range --revision @{1} --end-revision HEAD --keep-last findchanges
	bpfindshow = rev-range --revision @{1} --end-revision HEAD --keep-last findshow
	bplc = rev-range --revision @{1} --end-revision HEAD --one-more-command log lc
	bplcf = rev-range --revision @{1} --end-revision HEAD --one-more-command log lcf
	bplcl = rev-range --revision @{1} --end-revision HEAD lcl
	bplclf = rev-range --revision @{1} --end-revision HEAD lclf
	bplcmine = rev-range --revision @{1} --end-revision HEAD --one-more-command log lcmine
	bplcfmine = rev-range --revision @{1} --end-revision HEAD --one-more-command log lcfmine
	bpshow = rev-range --revision @{1} --end-revision HEAD --one-more-command log show
	bpshowfiles = rev-range --revision @{1} --end-revision HEAD showfiles
	bplog = rev-range --revision @{1} --end-revision HEAD --one-more log
	bplogv = rev-range --revision @{1} --end-revision HEAD --one-more logv
	bpglog = rev-range --revision @{1} --end-revision HEAD glog
	bpl = rev-range --revision @{1} --end-revision HEAD l
	bplmine = rev-range --revision @{1} --end-revision HEAD lmine
	bplg = rev-range --revision @{1} --end-revision HEAD --one-more lg
	bplgn = rev-range --revision @{1} --end-revision HEAD lg
	bplgv = rev-range --revision @{1} --end-revision HEAD --one-more lgv
	bplh = rev-range --revision @{1} --end-revision HEAD lh --reverse
	bplhmine = rev-range --revision @{1} --end-revision HEAD lhmine --reverse
	bplhurl = rev-range --revision @{1} --end-revision HEAD lhurl
	bplhourl = rev-range --revision @{1} --end-revision HEAD lhourl --reverse
	bplhuurl = rev-range --revision @{1} --end-revision HEAD lhuurl --reverse
	bplhourlv = rev-range --revision @{1} --end-revision HEAD lhourlv --reverse
	bplhuurlv = rev-range --revision @{1} --end-revision HEAD lhuurlv --reverse
	bplgmine = rev-range --revision @{1} --end-revision HEAD --one-more lgmine
	bplogmine = rev-range --revision @{1} --end-revision HEAD --one-more logmine
	bprbi = rev-range --revision @{1} --no-range --one-more-command ^ rebase -i
	bpbase = rev-range --revision @{1} --no-range name-rev --name-only

	;; b2p...: Log variants that cover the differences of the current branch to where the tip of the branch was second-last.
	b2pd = rev-range --revision @{2} --end-revision HEAD diff
	b2pdl = rev-range --revision @{2} --end-revision HEAD dl
	b2mal = rev-range --revision @{2} --end-revision HEAD format-patch
	b2pfindlogs = rev-range --revision @{2} --end-revision HEAD --keep-last findlogs
	b2pfindlogsv = rev-range --revision @{2} --end-revision HEAD --keep-last findlogsv
	b2pfindlg = rev-range --revision @{2} --end-revision HEAD --keep-last findlg
	b2pfindchanges = rev-range --revision @{2} --end-revision HEAD --keep-last findchanges
	b2pfindshow = rev-range --revision @{2} --end-revision HEAD --keep-last findshow
	b2plc = rev-range --revision @{2} --end-revision HEAD --one-more-command log lc
	b2plcf = rev-range --revision @{2} --end-revision HEAD --one-more-command log lcf
	b2plcl = rev-range --revision @{2} --end-revision HEAD lcl
	b2plclf = rev-range --revision @{2} --end-revision HEAD lclf
	b2plcmine = rev-range --revision @{2} --end-revision HEAD --one-more-command log lcmine
	b2plcfmine = rev-range --revision @{2} --end-revision HEAD --one-more-command log lcfmine
	b2pshow = rev-range --revision @{2} --end-revision HEAD --one-more-command log show
	b2pshowfiles = rev-range --revision @{2} --end-revision HEAD showfiles
	b2plog = rev-range --revision @{2} --end-revision HEAD --one-more log
	b2plogv = rev-range --revision @{2} --end-revision HEAD --one-more logv
	b2pglog = rev-range --revision @{2} --end-revision HEAD glog
	b2pl = rev-range --revision @{2} --end-revision HEAD l
	b2plmine = rev-range --revision @{2} --end-revision HEAD lmine
	b2plg = rev-range --revision @{2} --end-revision HEAD --one-more lg
	b2plgn = rev-range --revision @{2} --end-revision HEAD lg
	b2plgv = rev-range --revision @{2} --end-revision HEAD --one-more lgv
	b2plh = rev-range --revision @{2} --end-revision HEAD lh --reverse
	b2plhmine = rev-range --revision @{2} --end-revision HEAD lhmine --reverse
	b2plhurl = rev-range --revision @{2} --end-revision HEAD lhurl
	b2plhourl = rev-range --revision @{2} --end-revision HEAD lhourl --reverse
	b2plhuurl = rev-range --revision @{2} --end-revision HEAD lhuurl --reverse
	b2plhourlv = rev-range --revision @{2} --end-revision HEAD lhourlv --reverse
	b2plhuurlv = rev-range --revision @{2} --end-revision HEAD lhuurlv --reverse
	b2plgmine = rev-range --revision @{2} --end-revision HEAD --one-more lgmine
	b2plogmine = rev-range --revision @{2} --end-revision HEAD --one-more logmine
	b2prbi = rev-range --revision @{2} --no-range --one-more-command ^ rebase -i
	b2pbase = rev-range --revision @{2} --no-range name-rev --name-only

	;; out...: Log variants that cover the differences that already exist on the current branch, but not yet in the corresponding remote branch.
	outd = rev-range-outgoing '' diff
	outdl = rev-range-outgoing '' dl
	oumal = rev-range-outgoing '' format-patch
	outfindlogs = rev-range-outgoing '' --keep-last findlogs
	outfindlogsv = rev-range-outgoing '' --keep-last findlogsv
	outfindlg = rev-range-outgoing '' --keep-last findlg
	outfindchanges = rev-range-outgoing '' --keep-last findchanges
	outfindshow = rev-range-outgoing '' --keep-last findshow
	outlc = rev-range-outgoing '' --one-more-command log lc
	outlcf = rev-range-outgoing '' --one-more-command log lcf
	outlcl = rev-range-outgoing '' lcl
	outlclf = rev-range-outgoing '' lclf
	outlcmine = rev-range-outgoing '' --one-more-command log lcmine
	outlcfmine = rev-range-outgoing '' --one-more-command log lcfmine
	outshow = rev-range-outgoing '' --one-more-command log show
	outshowfiles = rev-range-outgoing '' showfiles
	outlog = rev-range-outgoing '' --one-more log
	outlogv = rev-range-outgoing '' --one-more logv
	outglog = rev-range-outgoing '' glog
	outl = rev-range-outgoing '' l
	outlmine = rev-range-outgoing '' lmine
	outlg = rev-range-outgoing '' --one-more lg
	outlgn = rev-range-outgoing '' lg
	outlgv = rev-range-outgoing '' --one-more lgv
	outlh = rev-range-outgoing '' lh --reverse
	outlhmine = rev-range-outgoing '' lhmine --reverse
	outlhurl = rev-range-outgoing '' lhurl
	outlhourl = rev-range-outgoing '' lhourl --reverse
	outlhuurl = rev-range-outgoing '' lhuurl --reverse
	outlhourlv = rev-range-outgoing '' lhourlv --reverse
	outlhuurlv = rev-range-outgoing '' lhuurlv --reverse
	outlgmine = rev-range-outgoing '' --one-more lgmine
	outlogmine = rev-range-outgoing '' --one-more logmine
	; outrbi would be the same as trbi.
	; outbase would be the same as tracks.

	;; in...: Log variants that cover the differences that already exist in remote on the current branch, but not yet in the local branch.
	ind = rev-range-incoming '' diff
	indl = rev-range-incoming '' dl
	inma = rev-range-incoming '' format-patch
	infindlogs = rev-range-incoming '' --keep-last findlogs
	infindlogsv = rev-range-incoming '' --keep-last findlogsv
	infindlg = rev-range-incoming '' --keep-last findlg
	infindchanges = rev-range-incoming '' --keep-last findchanges
	infindshow = rev-range-incoming '' --keep-last findshow
	inlc = rev-range-incoming '' --one-more-command log lc
	inlcf = rev-range-incoming '' --one-more-command log lcf
	inlcl = rev-range-incoming '' lcl
	inlclf = rev-range-incoming '' lclf
	inlcmine = rev-range-incoming '' --one-more-command log lcmine
	inlcfmine = rev-range-incoming '' --one-more-command log lcfmine
	inshow = rev-range-incoming '' --one-more-command log show
	inshowfiles = rev-range-incoming '' showfiles
	inlog = rev-range-incoming '' --one-more log
	inlogv = rev-range-incoming '' --one-more logv
	inglog = rev-range-incoming '' glog
	inl = rev-range-incoming '' l
	inlmine = rev-range-incoming '' lmine
	inlg = rev-range-incoming '' --one-more lg
	inlgn = rev-range-incoming '' lg
	inlgv = rev-range-incoming '' --one-more lgv
	inlh = rev-range-incoming '' lh --reverse
	inlhmine = rev-range-incoming '' lhmine --reverse
	inlhurl = rev-range-incoming '' lhurl
	inlhourl = rev-range-incoming '' lhourl --reverse
	inlhuurl = rev-range-incoming '' lhuurl --reverse
	inlhourlv = rev-range-incoming '' lhourlv --reverse
	inlhuurlv = rev-range-incoming '' lhuurlv --reverse
	inlgmine = rev-range-incoming '' --one-more lgmine
	inlogmine = rev-range-incoming '' --one-more logmine
	; inrbi doesn't make sense; you cannot rebase stuff in a remote branch.
	; inbase would be the same as tracks.

	;; oout...: Log variants that cover the differences that already exist on the current branch, but not yet in the corresponding origin branch.
	ooutd = rev-range-outgoing origin diff
	ooutdl = rev-range-outgoing origin dl
	oomatl = rev-range-outgoing origin format-patch
	ooutfindlogs = rev-range-outgoing origin --keep-last findlogs
	ooutfindlogsv = rev-range-outgoing origin --keep-last findlogsv
	ooutfindlg = rev-range-outgoing origin --keep-last findlg
	ooutfindchanges = rev-range-outgoing origin --keep-last findchanges
	ooutfindshow = rev-range-outgoing origin --keep-last findshow
	ooutlc = rev-range-outgoing origin --one-more-command log lc
	ooutlcf = rev-range-outgoing origin --one-more-command log lcf
	ooutlcl = rev-range-outgoing origin lcl
	ooutlclf = rev-range-outgoing origin lclf
	ooutlcmine = rev-range-outgoing origin --one-more-command log lcmine
	ooutlcfmine = rev-range-outgoing origin --one-more-command log lcfmine
	ooutshow = rev-range-outgoing origin --one-more-command log show
	ooutshowfiles = rev-range-outgoing origin showfiles
	ooutlog = rev-range-outgoing origin --one-more log
	ooutlogv = rev-range-outgoing origin --one-more logv
	ooutglog = rev-range-outgoing origin glog
	ooutl = rev-range-outgoing origin l
	ooutlmine = rev-range-outgoing origin lmine
	ooutlg = rev-range-outgoing origin --one-more lg
	ooutlgn = rev-range-outgoing origin lg
	ooutlgv = rev-range-outgoing origin --one-more lgv
	ooutlh = rev-range-outgoing origin lh --reverse
	ooutlhmine = rev-range-outgoing origin lhmine --reverse
	ooutlhurl = rev-range-outgoing origin lhurl
	ooutlhourl = rev-range-outgoing origin lhourl --reverse
	ooutlhuurl = rev-range-outgoing origin lhuurl --reverse
	ooutlhourlv = rev-range-outgoing origin lhourlv --reverse
	ooutlhuurlv = rev-range-outgoing origin lhuurlv --reverse
	ooutlgmine = rev-range-outgoing origin --one-more lgmine
	ooutlogmine = rev-range-outgoing origin --one-more logmine
	; ooutrbi would be the same as orbi.
	; ooutbase would always print "origin/<branch>".

	;; oin...: Log variants that cover the differences that already exist in origin on the current branch, but not yet in the local branch.
	oind = rev-range-incoming origin diff
	oindl = rev-range-incoming origin dl
	oimal = rev-range-incoming origin format-patch
	oinfindlogs = rev-range-incoming origin --keep-last findlogs
	oinfindlogsv = rev-range-incoming origin --keep-last findlogsv
	oinfindlg = rev-range-incoming origin --keep-last findlg
	oinfindchanges = rev-range-incoming origin --keep-last findchanges
	oinfindshow = rev-range-incoming origin --keep-last findshow
	oinlc = rev-range-incoming origin --one-more-command log lc
	oinlcf = rev-range-incoming origin --one-more-command log lcf
	oinlcl = rev-range-incoming origin lcl
	oinlclf = rev-range-incoming origin lclf
	oinlcmine = rev-range-incoming origin --one-more-command log lcmine
	oinlcfmine = rev-range-incoming origin --one-more-command log lcfmine
	oinshow = rev-range-incoming origin --one-more-command log show
	oinshowfiles = rev-range-incoming origin showfiles
	oinlog = rev-range-incoming origin --one-more log
	oinlogv = rev-range-incoming origin --one-more logv
	oinglog = rev-range-incoming origin glog
	oinl = rev-range-incoming origin l
	oinlmine = rev-range-incoming origin lmine
	oinlg = rev-range-incoming origin --one-more lg
	oinlgn = rev-range-incoming origin lg
	oinlgv = rev-range-incoming origin --one-more lgv
	oinlh = rev-range-incoming origin lh --reverse
	oinlhmine = rev-range-incoming origin lhmine --reverse
	oinlhurl = rev-range-incoming origin lhurl
	oinlhourl = rev-range-incoming origin lhourl --reverse
	oinlhuurl = rev-range-incoming origin lhuurl --reverse
	oinlhourlv = rev-range-incoming origin lhourlv --reverse
	oinlhuurlv = rev-range-incoming origin lhuurlv --reverse
	oinlgmine = rev-range-incoming origin --one-more lgmine
	oinlogmine = rev-range-incoming origin --one-more logmine
	; oinrbi doesn't make sense; you cannot rebase stuff in a remote branch.
	; oinbase would always print "origin/<branch>".

	;; uout...: Log variants that cover the differences that already exist on the current branch, but not yet in the corresponding upstream branch.
	uoutd = rev-range-outgoing upstream diff
	uoutdl = rev-range-outgoing upstream dl
	uomatl = rev-range-outgoing upstream format-patch
	uoutfindlogs = rev-range-outgoing upstream --keep-last findlogs
	uoutfindlogsv = rev-range-outgoing upstream --keep-last findlogsv
	uoutfindlg = rev-range-outgoing upstream --keep-last findlg
	uoutfindchanges = rev-range-outgoing upstream --keep-last findchanges
	uoutfindshow = rev-range-outgoing upstream --keep-last findshow
	uoutlc = rev-range-outgoing upstream --one-more-command log lc
	uoutlcf = rev-range-outgoing upstream --one-more-command log lcf
	uoutlcl = rev-range-outgoing upstream lcl
	uoutlclf = rev-range-outgoing upstream lclf
	uoutlcmine = rev-range-outgoing upstream --one-more-command log lcmine
	uoutlcfmine = rev-range-outgoing upstream --one-more-command log lcfmine
	uoutshow = rev-range-outgoing upstream --one-more-command log show
	uoutshowfiles = rev-range-outgoing upstream showfiles
	uoutlog = rev-range-outgoing upstream --one-more log
	uoutlogv = rev-range-outgoing upstream --one-more logv
	uoutglog = rev-range-outgoing upstream glog
	uoutl = rev-range-outgoing upstream l
	uoutlmine = rev-range-outgoing upstream lmine
	uoutlg = rev-range-outgoing upstream --one-more lg
	uoutlgn = rev-range-outgoing upstream lg
	uoutlgv = rev-range-outgoing upstream --one-more lgv
	uoutlh = rev-range-outgoing upstream lh --reverse
	uoutlhmine = rev-range-outgoing upstream lhmine --reverse
	uoutlhurl = rev-range-outgoing upstream lhurl
	uoutlhourl = rev-range-outgoing upstream lhourl --reverse
	uoutlhuurl = rev-range-outgoing upstream lhuurl --reverse
	uoutlhourlv = rev-range-outgoing upstream lhourlv --reverse
	uoutlhuurlv = rev-range-outgoing upstream lhuurlv --reverse
	uoutlgmine = rev-range-outgoing upstream --one-more lgmine
	uoutlogmine = rev-range-outgoing upstream --one-more logmine
	; uoutrbi would be the same as urbi.
	; uoutbase would always print "upstream/<branch>".

	;; uin...: Log variants that cover the differences that already exist in upstream on the current branch, but not yet in the local branch.
	uind = rev-range-incoming upstream diff
	uindl = rev-range-incoming upstream dl
	uimal = rev-range-incoming upstream format-patch
	uinfindlogs = rev-range-incoming upstream --keep-last findlogs
	uinfindlogsv = rev-range-incoming upstream --keep-last findlogsv
	uinfindlg = rev-range-incoming upstream --keep-last findlg
	uinfindchanges = rev-range-incoming upstream --keep-last findchanges
	uinfindshow = rev-range-incoming upstream --keep-last findshow
	uinlc = rev-range-incoming upstream --one-more-command log lc
	uinlcf = rev-range-incoming upstream --one-more-command log lcf
	uinlcl = rev-range-incoming upstream lcl
	uinlclf = rev-range-incoming upstream lclf
	uinlcmine = rev-range-incoming upstream --one-more-command log lcmine
	uinlcfmine = rev-range-incoming upstream --one-more-command log lcfmine
	uinshow = rev-range-incoming upstream --one-more-command log show
	uinshowfiles = rev-range-incoming upstream showfiles
	uinlog = rev-range-incoming upstream --one-more log
	uinlogv = rev-range-incoming upstream --one-more logv
	uinglog = rev-range-incoming upstream glog
	uinl = rev-range-incoming upstream l
	uinlmine = rev-range-incoming upstream lmine
	uinlg = rev-range-incoming upstream --one-more lg
	uinlgn = rev-range-incoming upstream lg
	uinlgv = rev-range-incoming upstream --one-more lgv
	uinlh = rev-range-incoming upstream lh --reverse
	uinlhmine = rev-range-incoming upstream lhmine --reverse
	uinlhurl = rev-range-incoming upstream lhurl
	uinlhourl = rev-range-incoming upstream lhourl --reverse
	uinlhuurl = rev-range-incoming upstream lhuurl --reverse
	uinlhourlv = rev-range-incoming upstream lhourlv --reverse
	uinlhuurlv = rev-range-incoming upstream lhuurlv --reverse
	uinlgmine = rev-range-incoming upstream --one-more lgmine
	uinlogmine = rev-range-incoming upstream --one-more logmine
	; uinrbi doesn't make sense; you cannot rebase stuff in a remote branch.
	; uinbase would always print "upstream/<branch>".


	last = cat-file commit HEAD	; Show last commit info: Hashes and author. Use "git show" for more details.
	;; lastmine: Show my last commit info: Hashes and author.
	changes = diff --name-status -r ; Subversion-like 'svn status' reporting.
	;; tagtype: List only those tags of the passed (annotated or lightweight) type.
	taglist-annotated = tagtype annotated
	taglist-lightweight = tagtype lightweight
	;; describe: Show the most recent tag that is reachable from a commit, in the format <annotated tag>-g<commits on top>-<commit-hash>.
	;; desc: Show current / passed revision relative to the most recent ref that is reachable from a commit, in the format <tag|ref>-g<commits on top>-<commit-hash>[-dirty].
	;; describe-version: Show (only the) most recent annotated tag (used for official versions etc.) that the current / passed revision is based on.
	contained-version = contained-command tag ; Show (only the) first annotated tag (used for official versions etc.) [that matches GREP-ARGS] that comes after the passed revision, and thus contains it.
	annotate-contained-version = annotate-contained-command version
	;; describe-tag: Show relation to the most recent, also lightweight (used for archiving) tag name for the current / passed revision.
	contained-tag = contained-command describe ; Show relation to the first tag (also lightweight, used for archiving) [that matches GREP-ARGS] that comes after the passed revision, and thus contains it.
	annotate-contained-tag = annotate-contained-command tag
	;; timestamp: Current build identifier containing the host, relation to previous tag, and build time.
	;; contains: Show in which tag(s) a commit is contained, i.e. in which versions this was shipped, or, if that fails, from which branch it can be reached.

	picks = cherrypicks -v --abbrev=7	; See which changes from the current branch (e.g. feature) are already present in the passed branch (e.g. master).
	;; conflicts: List files with merge conficts.
	;; conflictwipe: Abort the merge conflicts and MERGING / CHERRYPICKING state, e.g. when you want to wipe / change the working copy, anyway, and currently can't because of "error: you need to resolve your current index first".
	; Source: http://akahn.net/2011/10/12/working-through-git-conflicts-in-vim.html
	;; cob: Keep "base", the common ancestor in case of merge conflicts.
	;; coo: Keep "ours", the original one we had (ORIG_HEAD), or the one we're rebasing onto, in case of merge conflicts.
	;; cot: Keep "theirs", the version merged in (MERGE_HEAD), or the one from the branch we're rebasing, in case of merge conflicts.
	;; reflog: Show recorded changes to the tip of a branch, mostly to restore unreachable old commits via head@{1}.
	;; inout: Show incoming and outgoing commit logs between current / passed branch and its remote tracked branch / passed branch / corresponding remote branch of passed remote.
	io = inout

	cleanall = clean -d -x	; Remove all untracked files and directories, restoring a pristine working copy.
	;; lsprivate: Show all non-ignored files not under version control.
	;lsprivate = clean --dry-run ; Show all non-ignored files not under version control.
	;; rmprivate: Remove all non-ignored files not under version control.

	staged = diff --name-only --cached	; List staged files in index.
	;; editstage ; Directly edit file(s) in the index without modifying the corresponding files in the working copy.
	ei = editstage
	undelete = checkout HEAD -- ; Undo "git rm <file>"; puts the file back into working copy.
	unstage = reset HEAD --	; Undo "git add <file>"; removes the file from the index, so that it isn't committed. (Alternatively, you can commit a few files via "git commit <file>" directly, bypassing the index.)
	;; unstage ; Interactively select (from staged files or passed list of files) files (or directly pass N, M, ... selections) to remove from the index by number.
	unstagehunk = reset --patch HEAD --	; Interactively cherry-pick and remove individual hunks from the index.
	;; unstageselected ; Interactively select (from staged files or passed list of files) files (or directly pass N, M, ... selections) to remove from the index by number.
	uncommit = reset --soft HEAD^ ; Cancel the last commit; keep working copy and index.
	peel = reset --mixed HEAD^ ; Cancel the last commit also from index; keep only the working copy. With this, you can split a single commit during rebase.
	wipecommit = wipe HEAD^	; Completely remove the last commit, also from working copy and index. Ensures that the current branch isn't dirty.
	;; wipe: Reset HEAD, working copy and index [to <branch>] [<paths>...]. Ensures that the current branch isn't dirty.
	;; hardreset = reset --hard ; Reset HEAD, working copy and index to <branch>. Destructive without safety check (but needs a passed <branch>)!
	;; reset-to-tracked: Reset my current branch to the HEAD of the tracked branch. Use this when the local branch has been pointed elsewhere (e.g. due to an attempted rebase), and you want to restore the original state. The working copy is left intact.
	reset-back = reset ORIG_HEAD	; Undo a previous git reset; allows you to go back into the future after moving the HEAD to the past.
	track = branch --set-upstream-to	; Change the remote the current branch is tracking.
	;; tracks: Show which remote branch is tracked by the current branch.
	;
	;; pushall: Push all branches, tags, and notes (if exist).
	;; up: Pull and rebase the current branch from passed <remote>. (By default, pull prefers merges over rebasing). Handles a dirty working copy by temporarily stashing it. Shows a log of pulled changes.
	pull = pull --ff-only	; Get and fast-forward changes; don't merge or rebase. Let's do that explicitly via the corresponding commands.
	;; rtrack: Make the current branch track in the passed <remote> the passed <branch> / eponymous branch.
	rb = rebase
	; For merging, you switch to the target branch (e.g. master), then merge the source branch.
	; For rebasing, you stay in your working branch and rebase to master.
	; Therefore, the meaning of "ours" and "theirs" is somewhat unintuitive:
	; - what we have on the checked out master branch is 'ours',
	; - what we had (and is being merged or replayed) in our working branch is 'theirs'.
	; Possible actions:
	; 	a) Remove commits by deleting lines. Like the revert command, but off the
	; 	   record: it will be as if the commit never existed.
	; 	b) Reorder commits by reordering lines.
	; Replace pick with:
	;	d) "edit" to mark a commit for amending.
	;	e) "reword" to change the log message.
	;	f) "squash" to merge a commit with the previous one.
	;	g) "fixup" to merge a commit with the previous one and discard the log message.
	; During a rebase:
	; 	1. Resolve the conflicted files; "git conflicts" tells them (again)
	; 	   To completely override upstream's changes, we have to use "theirs" (from the branch being rebased, i.e. git cot), not "ours"; this is unintuitive!
	; 	2. git add # after the conflicts have been resolved
	; 	3. git rbc
	; It may help to have both our and their changes separately:
	; 	git lc master
	; 	git lc
	rbi = rebase -i
	; brrbi et al: see above
	rbc = rebase --continue	; Commit (after adding resolved conflicts) and continue with any subsequent commits to be cherry-picked.
	;; rbcu: addu + rbc: Stage modified files (i.e. those with resolved conflicts) and continue rebasing.
	rbs = rebase --skip	; Restart the rebasing process by skipping the current patch.
	rbq = rebase --abort	; Cancel the operation and return to the pre-sequence state.
	rbe = rebase --edit-todo	; Edit the todo list during an interactive rebase.
	rbu = reset @{1}
	;; git rebase HEAD <feature> && git rebase HEAD @{-2}: Rebase <feature> to current branch and merge back to current
	;; git rebase master --onto <newbase> <=> git bmrbi --onto <newbase>:	Rebase the changes in the current branch (with regards to master) to appear as if they were committed onto <newbase>. Can be used to move a set of commits to another base commit.
	;; git rebase HEAD^ --onto <newbase>:	Rebase the last commit to appear as if they were committed onto <newbase>.
	;; git rebaselocalbr: Rebase all / the last committed N local branches (except for the current branch and master (and base branch if defined)) to the updated passed (or configured in branch.<name>.remote and branch.<name>.merge) upstream head.
	;; git merge --squash: Create a single commit on top of the current branch whose effect is the same as merging the other branch. Shorter form of interactive rebasing where you choose squash for all following commits.
	; merging
	;; checkout --ours:   (or git coo) will keep the original one we had (ORIG_HEAD) in case of merge conflict
	;; checkout --theirs: (or git cot) will keep the version merged in (MERGE_HEAD) in case of merge conflict
	;; mergeto: Merge the current branch to <target-branch>.
	mergelb = merge @{-1}
	mergem = mergeto master
	mergen = base-command mergeto
	;; mergelocalbr: Merge all / the last committed N local branches (except for the current branch and master (and base branch if defined)).
	;; mergelocalbrc: Merge all / the last committed N local branches (except for the current branch and master (and base branch if defined)) ordered by date of first commit.
	mt = mergetool
	;; merge-base: Identify branch point (common ancestor).
	; The fast-forward command does the second part of git pull, it merges the
	; remote tracking branch. Use this when you've already fetched the changes
	; (to avoid the superfluous network exchange), and you get the message "Your
	; branch is behind 'origin/tracked-branch', and can be fast-forwarded."
	; after switching to a branch.
	; The --ff is the default, but specify it in case it has been overridden by
	; local config.
	fast-forward = -c merge.defaultToUpstream=true merge --ff
	ff = -c merge.defaultToUpstream=true merge --ff
	fflb = ff @{-1}
	;; mergesummary: Show enriched log (for passed remote) of the passed merge commit, including URLs to the merge commit, the merged changes, full commit message, and changed files.
	omergesummary = mergesummary origin
	umergesummary = mergesummary upstream

	noff = merge --no-ff
	nofflb =noff @{-1}
	;; reintegrate: Merge <branch> to the current branch, then delete it from the local repository as well as a tracked remote (if it exists there).
	reintegratelb = reintegrate --branch @{-1}
	;; reintegrateto: Merge the current branch to master / the passed <branch>, then delete it from the local repository as well as a tracked remote (if it exists there).
	reintegratetolb = reintegrateto --branch @{-1}
	reintegratetom = reintegrateto --branch master
	reintegrateton = base-command --keep-position reintegrateto --branch BASE

	fl = git-rev-fetch-command l --reverse ; l of fetched commits
	flc = git-rev-fetch-command lc --reverse ; lc of fetched commits
	flg = git-rev-fetch-command lg --reverse ; lg of fetched commits
	flog = git-rev-fetch-command log --reverse ; log of fetched commits
	fetched = diff --stat ..FETCH_HEAD	; Summary of all fetched commits.
	;; remote show <repo>: Remote repository info, including tracked remote branches.
	fetchall = remote update	; Fetch all configured remotes (except when remote.<name>.skipDefaultUpdate is configured).
	;; fetchdate: Show when (any) remote was last fetched.
	;; pushdate: Show when the current branch was last synchronized (pushed or pulled) with the tracked remote branch / passed remote.
	opushdate = pushdate origin
	upushdate = pushdate upstream
	;; updatedate: Show when the last update of the local repository (fetch or push) happened.
	;; uptodate: Check remote whether the current branch is on the same commit as the tracked remote branch / passed remote (or whether a fetch / push is needed).
	ouptodate = uptodate origin
	uuptodate = uptodate upstream

	tco = rev-tracked-command checkout ; checkout tracked branch HEAD
	tdiff = rev-tracked-command diff ; diff with tracked branch
	tl = rev-tracked-command l ; l of tracked branch
	tlc = rev-tracked-command lc ; lc of tracked branch
	tlg = rev-tracked-command lg ; lg of tracked branch
	tlog = rev-tracked-command log ; log of tracked branch
	treset = reset-to-tracked --must-be-origin	; Reset my current branch (and working tree with --hard) to the HEAD of tracked branch of origin. Use this when the local branch has been pointed elsewhere (e.g. due to an attempted rebase), and you want to restore the original state. The working copy is left intact.
	tmerge = rev-tracked-command merge ; Merge changes in tracked branch with my local repo.
	trb = rev-tracked-command rebase ; Rebase my commits on top of the tracked branch.
	trbi = rev-tracked-command rebase -i

	obrowse = browse origin
	oexists = existsremote origin
	obr = rbr origin ; List all branches in my GitHub clone [matching <pattern>].
	oco = rco origin ; Checkout local branch from origin.
	ocolatest = rcolatest origin ; Checkout local branch from latest (by sort order) upstream [matching pattern].
	ocolatestc = rcolatestc origin ; Checkout local branch from the upstream branch [matching pattern] that was created last (except the current branch and master (and base branch if defined)).
	;; ocreatelocalbr: Create (and track) local branches for all branches in origin (matching PATTERN).
	;; oprune: Remove old local branches that do not exist in origin any more.
	odiff = rev-remote-command origin diff ; Show differences to my GitHub clone.
	ol = rev-remote-command origin l; l of origin
	olc = rev-remote-command origin lc; lc of origin
	olg = rev-remote-command origin lg; lg of origin
	olog = rev-remote-command origin log; Log of my GitHub clone.
	oio = inout origin
	omio = inout master origin/master
	onio = base-command -2 BASE origin/BASE inout
	omrb = rebase origin/master	; Rebase my commits on top of the latest main branch of my GitHub clone.
	onrb = base-command -2 BASE origin/BASE rebase ; Rebase my commits on top of the latest base branch of my GitHub clone.
	ofetch = fetch --prune origin ; Get changes done to my GitHub clone through another Git repository, e.g. from another system. Use this, followed by git owipe, when origin has been reset (e.g. to an updated upstream).
	opull = pull --ff-only --prune origin ; Get and fast-forward changes done to my GitHub clone through another Git repository, e.g. from another system. This allows to either merge or rebase (recommended) when local commits have been done to an outdated local branch.
	oup = up origin
	omerge = rev-remote-command origin merge ; Merge changes done to my GitHub clone through another Git repository with my local repo.
	opa = pushall origin	; Push all branches, tags, and notes (if exist) to origin.
	opush = push origin ; Re-publish of current / passed <branch> to the tracking GitHub clone to get them pulled into upstream.
	opublish = rpublish origin ; Initial publish of current / passed <branch> to my GitHub clone to get them pulled into upstream.
	; ... and set upstream tracking reference so that future pushes can omit the branch name (when push.default=tracking).
	; Instead, I could probably also setup automatic tracking, but:
	; - would lose the warning when trying to opush a branch that I haven't
	;   published yet.
	; - would default to pushing to foreign branches from someone (which I'm
	;   not allowed), instead of being forced to publish to my own GitHub
	;   clone.
	;
	;   git config branch.autosetupmerge true
	; tells git-branch and git-checkout to setup new branches so that git-pull(1)
	; will appropriately merge from that remote branch.  Recommended.  Without this,
	; you will have to add --track to your branch command or manually merge remote
	; tracking branches with "fetch" and then "merge".
	odeletebr = push origin --delete ; Delete remote <branch> in my GitHub clone. Older git must use "push origin :BRANCHNAME"
	oldeletebr = rldeletebr origin ; Delete <branch> from the local repository as well as origin.
	olrenamebr = rlrenamebr origin ; Rename current / <oldbranch> to <newbranch> in both local repository and origin.
	oreset = rev-remote-command origin reset ; Reset my current branch to the HEAD of the corresponding / passed branch of origin. The working copy is left intact, so you can effectively rebase any outstanding differences with a follow-up commit.
	ohardreset = rev-remote-command origin reset --hard ; Reset my current branch to the HEAD of the corresponding / passed branch of upstream.
	otrack = rtrack origin	; Make the current branch track the eponymous branch in origin.
	oremotebr = remotebr origin	; Print corresponding origin/branch for the current / passed branch(es) (or return error).
	oreset = rev-remote-command origin reset ; Reset my current branch to the HEAD of the corresponding / passed branch in origin.
	owipe = rev-remote-command origin wipe ; Reset my current branch to the HEAD of the corresponding / passed branch of origin. Use this after an ureset done in another repository. Ensures that the current branch isn't dirty.

	; How to add the upstream repository to my own repository:
	;	git remote add upstream http://repo.or.cz/r/vcscommand.vim.git
	; Note: HTTPS is the default, but I've seen failures behind the corporate
	; firewall. On there other hand, I got a 403 when using HTTP.
	ubrowse = browse upstream
	uexists = existsremote upstream
	ubr = rbr upstream ; List all branches in upstream [matching <pattern>].
	upicks = rev-remote-command upstream cherrypicks -v --abbrev=7 ; See which changes from the current branch are already present upstream.
	uco = rco upstream ; Checkout local branch from upstream.
	ucolatest = rcolatest upstream ; Checkout local branch from latest (by sort order) upstream [matching pattern].
	ucolatestc = rcolatestc upstream ; Checkout local branch from the upstream branch [matching pattern] that was created last (except the current branch and master (and base branch if defined)).
	ucom = checkout upstream/master ; Use with -b <newbranch> to start a patch based on the current upstream.
	ucon = base-command -1 upstream/BASE checkout ; Use with -b <newbranch> to start a patch based on the current upstream's base branch.
	umdiff = diff master..upstream/master ; Show differences introduced in upstream relative to master; useful to review upstream changes before pulling them in.
	undiff = base-command -1 BASE..upstream/BASE diff ; Show differences introduced in upstream relative to the base branch; useful to review upstream changes before pulling them in.
	udiff = rev-remote-command upstream diff ; Show differences to upstream.
	ul = rev-remote-command upstream l ; l of upstream
	ulc = rev-remote-command upstream lc ;: lc of upstream
	ulg = rev-remote-command upstream lg ;: lg of upstream
	ulog = rev-remote-command upstream log ; Log of upstream.
	umlog = rev-branch-remotebr-command upstream master log ; Show log of changes introduced in upstream relative to master; useful to review upstream changes before pulling them in.
	unlog = base-command --keep-position rev-branch-remotebr-command upstream BASE log ; Show log of changes introduced in upstream relative to base; useful to review upstream changes before pulling them in.
	umlg = rev-branch-remotebr-command upstream master lg ; Show one-line log of changes introduced in upstream relative to master; useful to review upstream changes before pulling them in.
	unlg = base-command --keep-position rev-branch-remotebr-command upstream BASE lg ; Show one-line log of changes introduced in upstream relative to base; useful to review upstream changes before pulling them in.
	umlc = rev-branch-remotebr-command upstream master lc ; Show log and diff of changes introduced in upstream relative to master; useful to review upstream changes before pulling them in.
	unlc = base-command --keep-position rev-branch-remotebr-command upstream BASE lc ; Show log and diff of changes introduced in upstream relative to base; useful to review upstream changes before pulling them in.
	uio = inout upstream
	umio = inout master upstream/master
	unio = base-command -2 BASE upstream/BASE inout
	umrb = rebase upstream/master	; Rebase my commits on top of the latest main upstream branch. "co mybranch" first, clone it via "git co -b mybranch-old; git opublish" if you want to keep the old one, or just use "umrb mybranch". You can also do this after the rebase, but before pushing: "git tco -b mybranch-old; git opublish; git co mybranch". Persist with "git opush -f"; undo with "git treset --hard".
	unrb = base-command -1 upstream/BASE rebase ; Rebase my commits on top of the latest base upstream branch.
	ufetch = fetch --prune upstream	; Get upstream changes.
	;; upull: Get and fast-forward upstream changes. (With proper use of other branches for patches, there should not be a need to merge upstream.) Use for direct checkouts of upstream, without my own origin. Else, prefer ucatchup.
	;; upush: push upstream ; Directly push current / passed <branch> to upstream.
	upublish = rpublish upstream ; Initial publish of current / passed <branch> directly to upstream (without using an origin clone (for now)).
	;; uopush: push upstream + origin; Directly push current / passed <branch> to upstream and (if successful) push it to the tracking GitHub clone, too.
	;; uup: up upstream
	umerge = rev-remote-command upstream merge ; Merge upstream changes with my local repo.
	urb = rev-remote-command upstream rebase ; Rebase my commits on top of the corresponding branch in upstream (or passed <branch>).
	urbi = rev-remote-command upstream rebase -i
	;; urebaselocalbr: Rebase all / the last committed N local branches (except for the current branch and master (and base branch if defined)) to the updated upstream head. After that, merge again via git uwipem && git mergelocalbrc; then use git opush -f --all to send the rebased branches to origin.
	; To make pull default to rebase instead of merge, can use these:
	; # make "git pull" on master always use rebase
	; $ git config branch.master.rebase true
	; You can also set up a global option to set the last property for every
	; new tracked branch:
	; # setup rebase for every tracking branch
	; $ git config --global branch.autosetuprebase always
	; Source: http://mislav.uniqpath.com/2010/07/git-tips/
	udeletebr = push upstream --delete ; Delete remote <branch> in upstream. Older git must use "push origin :BRANCHNAME"
	uldeletebr = rldeletebr upstream ; Delete <branch> from the local repository as well as upstream.
	ulrenamebr = rlrenamebr upstream ; Rename current / <oldbranch> to <newbranch> in both local repository and upstream.

	;; oadd: Add origin repository and fetch it. Offers to rename original origin to upstream.
	uadd = remote add -f upstream	; Add upstream repository and fetch it.
	radd = remote add -f	; Add remote repository and fetch it.
	; other foreign repositories
	; To import someone's repository and work on it, do this:
	;   # Import.
	;   git remote add -f <someone> https://github.com/<someone>/<project>.git
	;   # The -f already did: git fetch <someone>
	;   # What has changed in his branch?
	;   git diff upstream/master..<someone>/<branch>
	;   git co -b <branch> <someone>/<branch>
	;   # Do changes ...
	;   # Publish to your GitHub clone to make the changes accessible to someone.
	;   git opublish <branch>
	uremotebr = remotebr upstream	; Print corresponding upstream/branch for the current / passed branch(es) (or return error).
	ureset = rev-remote-command upstream reset ; Reset my current branch to the HEAD of the corresponding / passed branch of upstream. Use this after my pull requests have been accepted into upstream (but cherry-picked, in a different order, or intermingled with other requests, so that the commit history deviates from mine), but there are still pending changes. The working copy is left intact, so you can effectively rebase any outstanding differences with a follow-up commit.
	uhardreset = rev-remote-command upstream reset --hard ; Reset my current branch to the HEAD of the corresponding / passed branch of upstream.
	uwipe = rev-remote-command upstream wipe ; Reset my current branch to the HEAD of the corresponding / passed branch of upstream. Ensures that the current branch isn't dirty.
	;; uwipem: Switch to my master branch and reset it to the HEAD of the upstream/master.
	;; uwipen: Switch to my base branch and reset it to the HEAD of the upstream/base.
	;; urestore: Reset my current branch to the HEAD of the current / passed branch of upstream, and push this to my GitHub clone. Use this after my pull requests have been accepted into upstream (but cherry-picked, in a different order, or intermingled with other requests, so that the commit history deviates from mine). Ensures that the current branch isn't dirty.
	;; ucatchup: uup + urestore; Pull and rebase upstream changes (onto potentially dirty working copy), and push this to my GitHub clone. Use this when you directly follow upstream, and want to update your repo to its most recent version.
	;; ucatchup-hushed: Variant of ucatchup that suppresses standard fetch / rebase information and messages when there are no changes in upstream. Useful when updating many repositories e.g. with git-wcdo.

	; How to create a new GitHub repository:
	; 1. git init myproject
	; 2. On GitHub, create a new repository.
	; 3. git remote add origin git@github.com:inkarkat/myproject.git
	; 4. git push -u origin master
	;
	; with the hub extension:
	; 2. [git cd]
	; 3. git create -d "description"
	; 4. git opublish
	;
	; How to fork a non-GitHub repository:
	; 1. git clone --origin=upstream http://repo.or.cz/r/vcscommand.vim.git
	; 2. On GitHub, create a new repository.
	; 3. cd vcscommand.git
	; 4. git remote add origin git@github.com:inkarkat/vcscommand.vim.git
	; 5. git push -u origin master

	;; writebackup-import: Import a directory hierarchy into Git, using existing backup files with a current date file extension as history.
	;; writebackup-ingo-import: Import a directory hierarchy into Git, extracting the commit messages from ingo's custom changelog file header from existing backup files with a current date file extension as history.
	;; remotes: Show remotes with URLs.
	;; remoteurl: Show URL of <name> (as HTTPS, even if SSH access is configured). ("hub browse -u" apparently only can do this for origin.)
	ourl = remoteurl origin
	uurl = remoteurl upstream
	;; existsremote: Check whether the passed remote has been configured in the working copy.
	;; existsremoteurl: Check whether the passed remote name / URL offers a remote repository.

	; Submodule handling; taken from http://git-scm.com/book/en/v2/Git-Tools-Submodules
	;; sdiff: Show diff of repository and any submodules, too.
	spush = push --recurse-submodules=on-demand	; Goes into each submodule and manually pushes to the remotes to make sure they're externally available.
	supdate = submodule update --remote --merge	; Update and merge our changes with upstream changes to the submodule.

	;; cr: Show GitHub issues and pull requests (separately).
	;; crrecent: Show recently (default 2 weeks) updated GitHub issues and pull requests (separately), including the relative creation date.
	;; crstatus: Show number of issues and pull requests.
	myissues = me-in-github-command --assignee= issue
	issuesfromme = me-in-github-command --creator= issue
	issuesaboutme = me-in-github-command --mentioned= issue
	mycrs = me-in-github-command --assignee= cr
	crsfromme = me-in-github-command --creator= cr
	crsaboutme = me-in-github-command --mentioned= cr
	myprs = me-in-github-command --assignee= pr
	prsfromme = me-in-github-command --creator= pr
	prsaboutme = me-in-github-command --mentioned= pr
