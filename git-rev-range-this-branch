#!/bin/bash

printUsage()
{
    cat <<HELPTEXT
Print / execute GIT-COMMAND with the revision range that comprises the current
branch; possibly including one previous commit (from which was branched off).
The revision range (with --no-range, only the starting revision will be used) is
appended at the end of GIT-COMMAND ...; with --keep-last, it is put between the
next-to-last and last arguments.
A different GIT-COMMAND2 can be used for the --one-more revision; with ^[1|2],
the modifier instead is appended to the revision, and there's only one
invocation of GIT-COMMAND.
HELPTEXT
printf 'Usage: %q %s\n' "$(basename "$1")" '[--no-range] [-a|--any|-r|--include-remote-refs|-t|--include-tags [...]] [--keep-last] [+1|--one-more|--one-more-command GIT-COMMAND2|^[1|2]] [GIT-COMMAND ...] [-?|-h|--help]'
}

isAny=
typeset -a include=('heads')
isKeepLastArgument=
isShowOneMore=
showOneMoreCommand=
previousRevModifier=
range=..
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--any|-a)	shift; isAny=t;;
	--include-remote-refs|-r)	shift; include+=('remotes');;
	--include-tags|-t)		shift; include+=('tags');;
	--keep-last)	shift; isKeepLastArgument=t;;
	--one-more|+1)	shift; isShowOneMore=t;;
	--one-more-command)
			shift
			if [ "${1:0:1}" = '^' ]; then
			    previousRevModifier=$1
			else
			    isShowOneMore=t; showOneMoreCommand=$1
			fi
			shift
			;;
	--no-range)	shift; range=;;
	*)		break;;
    esac
done

contains()
{
    needle=$1
    shift
    for elem
    do
    [ "$needle" = "$elem" ] && return 0
    done
    return 1
}

previousRev=HEAD
while :
do
    # This will exit eventually with "fatal: Not a valid object name REV^"
    previousRev=$(git describe --abbrev=0 --all "${previousRev}^") || exit $?
    [ "$isAny" ] && break
    contains "${previousRev%%/*}" "${include[@]}" && break
done


if [ $# -eq 0 ]; then
    printf '%s%s%s\n' "$previousRev" "${previousRevModifier}${isShowOneMore:+^}" "$range"
elif [ "$isShowOneMore" ]; then
    # Because of the piping into the pager, we need to explicitly enable color.
    # Don't do this if the user explicitly turned it off, though.
    typeset -a colorArg=(--color=always)
    if [ ! -t 1 ] || contains '--no-color' "$@" || contains '--color=never' "$@"; then
	colorArg=()
    fi

    if [ $# -gt 0 -a "$isKeepLastArgument" ]; then
	git "${@:1:$(($#-1))}" "${colorArg[@]}" "${previousRev}${range}" "${!#}" &&
	    "${showOneMoreCommand:-$1}" "${@:2:$(($#-1))}" --max-count 1 "${colorArg[@]}" "${previousRev}^"
    else
	git "$@" "${colorArg[@]}" "${previousRev}${range}" &&
	    git "${showOneMoreCommand:-$1}" "${@:2:$(($#-1))}" --max-count 1 "${colorArg[@]}" "${previousRev}^"
    fi | "${PAGER:-less}" --RAW-CONTROL-CHARS
else
    if [ $# -gt 0 -a "$isKeepLastArgument" ]; then
	exec git "${@:1:$(($#-1))}" "${previousRev}${previousRevModifier}${range}" "${!#}"
    else
	exec git "$@" "${previousRev}${previousRevModifier}${range}"
    fi
fi
