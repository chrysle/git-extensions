#!/bin/bash

printUsage()
{
    cat <<HELPTEXT
Execute "git SIMPLECOMMAND" and/or COMMANDLINE on each passed WORKING-COPY.
Puts a header line (unless --no-header) that contains the WORKING-COPY name
(with --branch-name: also the current Git branch) before the command output.
--skip-files		Silently skip files that are passed as WORKING-COPY
			(e.g. resulting from a file glob).
--skip-foreign|-s	Silently skip directories that are not a Git working
			copy (instead of printing an error message).
--foreign-command CMD	Execute CMD in (accessible) directories that are not
			a Git working copy (e.g. to initialize a Git repo).
--predicate-command CMD	Skip working copies where CMD fails. This is an
			alternative to --command "if CMD; then COMMANDLINE; fi"
			that lets you still use SIMPLECOMMAND.
Note: For paging and headers, this command has to control Git's color output.
Pass --no-git-color if "git SIMPLECOMMAND" does not support the --color=...
arguments. (For COMMANDLINE you have to insert "\${gitColorArg[@]}" yourself.)
You can still pass --color=always if you pipe this command's output yet still
want coloring of headers.
Returns the last non-successful exit status. With --single-success,
non-successful executions are ignored unless all of them fail. In other words,
exit status is 0 if at least command in one WORKING-COPY succeeded.
HELPTEXT
    printf 'Usage: %q %s\n' "$(basename "$1")" '[--no-pager] [--no-header|--branch-name] [--no-git-color] [--single-success] [--skip-files] [-s|--skip-foreign|--foreign-command "COMMANDLINE" [...]] [--predicate-command "COMMANDLINE" [...]] [-c|--command "COMMANDLINE" [-c ...]] WORKING-COPY [...] [-- SIMPLECOMMAND ...] [-?|-h|--help]'
}

typeset -a pager=("${PAGER:-less}" --RAW-CONTROL-CHARS); [ -t 1 ] || pager=()
isSingleSuccess=
isSkipFiles=
isSkipForeign=
typeset -a foreignCommands=()
typeset -a predicateCommands=()
isNeedEval=
typeset -a commands=()
isHeader=t
isBranchName=
emptyHeaderFilterCommand=filterEmptyHeaders
isGitColor=t
typeset -a colorArg=()
typeset -a args=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--single-success)	shift; isSingleSuccess=t;;
	--skip-files)		shift; isSkipFiles=t;;
	--skip-foreign|-s)	shift; isSkipForeign=t;;
	--foreign-command)	shift; foreignCommands+=(${foreignCommands:+;} "$1"); shift;;
	--predicate-command)	shift; predicateCommands+=(${predicateCommands:+&&} "$1"); shift;;
	--command|-c)	shift; commands+=(${commands:+;} "$1"); isNeedEval=t; shift;;
	--no-pager)	shift; pager=();;
	--no-header)	shift; isHeader=; emptyHeaderFilterCommand=;;
	--branch-name)	shift; isBranchName=t;;
	--no-git-color)	shift; isGitColor=;;
	--no-color|--color=*)	colorArg=("$1"); shift;;
	--color)		colorArg=("$1" "$2"); shift; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		args+=("$1"); shift;;
    esac
done
if [ ${#args[@]} -eq 0 ]; then
    printUsage "$0" >&2
    exit 2
fi

# If we're launched from within a Git operation (e.g. the external editor opened
# by git commit), the environment variable GIT_DIR may have been set, and this
# causes the Git commands here to not find the repository for FILEs.
unset GIT_DIR

# As we change directories, need to first convert all passed working copies to
# absolute dirspecs.
typeset -a wcs=()
for arg in "${args[@]}"
do
    wcs+=("$(realpath --no-symlinks -- "$arg")")
done

# With piping into withHeader / pager, we need to explicitly enable color,
# unless this command's output itself is redirected. Also don't do this if the
# user explicitly turned off color.
determineColor()
{
    local firstArg="${colorArg[0]}"
    case "$firstArg" in
	--color=*)	printf "${firstArg#*=}";;
	--no-color)	printf 'never';;
	--color)	printf "${colorArg[1]}";;
    esac
}
if [ ! -t 1 ] && [ "$(determineColor)" != 'always' ] || [ ! "$pager" -a ! "$isHeader" ] || [ "$(determineColor)" = 'never' ]; then
    colorArg=()
else
    colorArg=(--color=always)
fi
gitColorArg=("${colorArg[@]}")
if [ ! "$isGitColor" ]; then
    gitColorArg=()

    typeset -a argsWithoutColor=()
    for arg
    do
	case "$arg" in
	    --color=*|--no-color)   ;;
	    *)			    argsWithoutColor+=("$arg");;
	esac
    done
    set -- "${argsWithoutColor[@]}"
fi
readonly gitCommand="$(which hub || which git)"
if [ $# -ne 0 ]; then
    if [ "$isNeedEval" ]; then
	# Combine --command and SIMPLECOMMAND; need to quote SIMPLECOMMAND to
	# undo the effects of eval.
	commands+=(${commands:+;} $(printf '%q ' "$gitCommand" "$@"))
    else
	commands=("$@")
    fi
fi
[ ${#commands[@]} -eq 0 ] && commands=(noop)



set -o pipefail
wcdo()
{
    headerId="wcdo-$$"
    isSuccess=
    status=0
    for dirspec in "${wcs[@]}"
    do
	if ! cd "$dirspec" 2>/dev/null; then
	    [ -n "$isSkipFiles" -a ! -d "$dirspec" -a -e "$dirspec" ] && continue
	    printf >&2 'ERROR: Cannot chdir to %s!\n' "$dirspec"
	    status=1; continue
	fi
	if ! ROOT=$(git root 2>/dev/null); then
	    if [ ${#foreignCommands[@]} -gt 0 ]; then
		if [ "$isHeader" ]; then
		    header="${dirspec##*/}"
		    [ "$isBranchName" ] && header="${header%.*} outside Git"
		fi
		eval "${foreignCommands[@]}" "${isHeader:+2>&1 | withHeader "${colorArg[@]}" --id '$headerId' -- '$header'}" && isSuccess=t || status=$?
	    elif [ ! "$isSkipForeign" ]; then
		printf >&2 'ERROR: %s is not inside a Git working copy!\n' "$dirspec"
		status=1
	    fi
	    continue
	fi

	if [ ${#predicateCommands[@]} -gt 0 ]; then
	    eval "${predicateCommands[@]}" || continue
	fi

	if [ "$isHeader" ]; then
	    header="${dirspec##*/}"
	    [ "$isBranchName" ] && header="${header%.*} on $(git-brname || echo 'unknown branch')"
	fi

	if [ "$isNeedEval" ]; then
	    eval "${commands[@]}" "${isHeader:+2>&1 | withHeader "${colorArg[@]}" --id '$headerId' -- '$header'}" && isSuccess=t || status=$?
	else
	    eval '"$gitCommand" "${commands[@]}" "${gitColorArg[@]}"' "${isHeader:+2>&1 | withHeader "${colorArg[@]}" --id '$headerId' -- '$header'}" && isSuccess=t || status=$?
	fi
    done

    if [ "$isSingleSuccess" ]; then
	[ "$isSuccess" ]
    else
	return $status
    fi
}

eval 'wcdo "$@" 2>&1' "${pager:+|}" '"${pager[@]}"'
